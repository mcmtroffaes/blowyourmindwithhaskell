

<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="A Haskell tutorial">
        <meta name="viewport" content="width=device-width">
        <title>Using Records in Agda &mdash; Blow Your Mind With Haskell</title>
            <link rel="stylesheet" href="../../../_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/main.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/minimal5.css" type="text/css">
            <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="../../../_static/webfont.css" type="text/css">
        <!-- Load modernizr and JQuery -->
        <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="../../../_static/plugins.js"></script>
        <script src="../../../_static/main.js"></script>
        <link rel="next" title="A First Attempt at Real Numbers in Agda" href="../../01/15/a_first_attempt_at_real_numbers_in_agda.html" /><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="../../../_static/disqus.js"></script></head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container">
  <nav>
    <ul><li class="quicklink"><div class="rss">
        <a href="../../../rss.html" title="Subscribe via RSS"><span class="webfont">B</span></a>
    </div></li><li class="main-nav">
          <a href="../../../index.html">Home</a>
        </li>
      <li class="main-nav">
          <a href="../../../pages/about.html">About</a>
        </li>
      </ul>
  </nav>

  <header>
            <hgroup>
              <h1><a href="../../../index.html">Blow Your Mind With Haskell</a></h1><h2>Musings of a Haskell Learner</h2></hgroup>
          </header>
      <div class="main-container"><div class="main wrapper clearfix"><article><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="../../01/15/a_first_attempt_at_real_numbers_in_agda.html">A First Attempt at Real Numbers in Agda</a> &raquo; </li>
        </ul><div class="timestamp postmeta">
            <span>25 March 2014</span>
        </div>
    <div class="section" id="using-records-in-agda">
<h1>Using Records in Agda</h1>
<div class="section" id="organizing-code">
<h2>Organizing Code</h2>
<p>In previous posts, we covered some of the basic principles behind Agda.
We discussed the use of data types to describe axioms of our theory,
and the use of functions to prove theorems from those axioms.
Using just data types and functions, however,
it is quite hard to recycle properties in a convenient way.
For this purpose, Agda provides a special bit of syntax: records.</p>
<p>Essentially, a record is a glorified data type.
Glorified in two ways:
(i) parameters can have names (called <em>fields</em>), and
(ii) we can embed declarations inside records.
In this post, we will only discuss the first point, fields.</p>
<p>For example, let us revisit the mock real type that we declared in our
earlier post:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="kr">data</span> ℝ <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="nf">r0</span> <span class="ow">:</span> ℝ
  <span class="nf">r1</span> <span class="ow">:</span> ℝ
  <span class="nf">_+_</span> <span class="ow">:</span> ℝ <span class="ow">-&gt;</span> ℝ <span class="ow">-&gt;</span> ℝ

<span class="kr">data</span> _==_ <span class="ow">:</span> ℝ <span class="ow">-&gt;</span> ℝ <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="nf">AXrefl==</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> r
  <span class="nf">AXsymm==</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> s <span class="ow">==</span> r
  <span class="nf">AXtrans==</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> s <span class="ow">==</span> t <span class="ow">-&gt;</span> r <span class="ow">==</span> t
  <span class="nf">AX+0</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r<span class="o">}</span> <span class="ow">-&gt;</span> <span class="o">(</span>r + r0<span class="o">)</span> <span class="ow">==</span> r
  <span class="nf">AXsymm+</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s<span class="o">}</span> <span class="ow">-&gt;</span> <span class="o">(</span>r + s<span class="o">)</span> <span class="ow">==</span> <span class="o">(</span>s + r<span class="o">)</span>
  <span class="nf">AX+==</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> <span class="o">(</span>r + t<span class="o">)</span> <span class="ow">==</span> <span class="o">(</span>s + t<span class="o">)</span>
</pre></div>
</div>
<p>How can we make this nicer?
Well, it would be quite nice if we could
somehow seperate the first three axioms that turn <span class="docutils literal"><span class="pre">_==_</span></span> into an
equivalence relation.
Secondly, there might be many different ways
in which we can actually construct an equivalence relation on a type.
In fact, we might work with different equivalence relations at the same time.
How can we generically say that some arbitrary relation, say <span class="docutils literal"><span class="pre">_≈_</span></span>,
is an equivalence relation?</p>
</div>
<div class="section" id="parametric-data-types-in-overdrive">
<h2>Parametric Data Types in Overdrive</h2>
<p>Well, we could specify the relation itself as a parameter,
along with proofs of the properties it needs to satisfy.</p>
<p>Here is one way:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="kr">data</span> IsEquivalence
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="o">(</span>_≈_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>

  <span class="nf">isEquivalence</span> <span class="ow">:</span>
    <span class="o">(</span>refl <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ r<span class="o">)</span>
    <span class="ow">-&gt;</span> <span class="o">(</span>symm <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> s ≈ r<span class="o">)</span>
    <span class="ow">-&gt;</span> <span class="o">(</span>trans <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> s ≈ t <span class="ow">-&gt;</span> r ≈ t<span class="o">)</span>
    <span class="ow">-&gt;</span> IsEquivalence _≈_
</pre></div>
</div>
<p>So, if we can create an instance of the type <span class="docutils literal"><span class="pre">IsEquivalence</span></span>
for some relation <span class="docutils literal"><span class="pre">_≈_</span></span>, then <span class="docutils literal"><span class="pre">_≈_</span></span> is an equivalence relation.
Here is an example of how we might use <span class="docutils literal"><span class="pre">IsEquivalence</span></span>:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="kr">data</span> ℕ <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="nf">zero</span> <span class="ow">:</span> ℕ
  <span class="nf">suc</span> <span class="ow">:</span> ℕ <span class="ow">-&gt;</span> ℕ

<span class="kr">data</span> _==_ <span class="ow">:</span> ℕ <span class="ow">-&gt;</span> ℕ <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="nf">natrefl</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>n<span class="o">}</span> <span class="ow">-&gt;</span> n <span class="ow">==</span> n

<span class="nf">theorem-==-symm</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>n m<span class="o">}</span> <span class="ow">-&gt;</span> n <span class="ow">==</span> m <span class="ow">-&gt;</span> m <span class="ow">==</span> n
theorem-==-symm natrefl <span class="ow">=</span> natrefl

<span class="nf">theorem-==-trans</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>n m k<span class="o">}</span> <span class="ow">-&gt;</span> n <span class="ow">==</span> m <span class="ow">-&gt;</span> m <span class="ow">==</span> k <span class="ow">-&gt;</span> n <span class="ow">==</span> k
theorem-==-trans natrefl natrefl <span class="ow">=</span> natrefl

<span class="nf">theorem-==-is-equivalence</span> <span class="ow">:</span> IsEquivalence _==_
theorem-==-is-equivalence
  <span class="ow">=</span> isEquivalence natrefl theorem-==-symm theorem-==-trans
</pre></div>
</div>
<p>Note that in the above example,
only reflexivity had to be specified as an axiom of <span class="docutils literal"><span class="pre">_==_</span></span>, and
the other properties could be proved from the definition of <span class="docutils literal"><span class="pre">_==_</span></span>
(of course this will not be the case in general!).</p>
<p>This is very generic already.
Can we do better? What are the problems with the above approach?</p>
<p>An obvious problem occurs if we have to specify
many parameters. Whenever we need
the it <span class="docutils literal"><span class="pre">isEquivalence</span></span> constructor,
we also need to specify three proofs.
Three is perhaps not that bad,
but for structures with many more properties,
we might get the ordering of arguments wrong.</p>
<p>The same issue occurs when we want to use <span class="docutils literal"><span class="pre">IsEquivalence</span></span>
as a premise of a theorem.
For example:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="kr">data</span> ⊥ <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
<span class="nf">¬_</span> <span class="ow">:</span> <span class="kt">Set</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
¬ A <span class="ow">=</span> A <span class="ow">-&gt;</span> ⊥
<span class="nf">theorem-equivalence-simple</span> <span class="ow">:</span>
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="ow">-&gt;</span> <span class="o">{</span>_≈_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="ow">-&gt;</span> IsEquivalence _≈_
  <span class="ow">-&gt;</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> ¬ <span class="o">(</span>s ≈ t<span class="o">)</span> <span class="ow">-&gt;</span> ¬ <span class="o">(</span>r ≈ t<span class="o">)</span>
theorem-equivalence-simple
  <span class="o">(</span>isEquivalence refl symm trans<span class="o">)</span>
  r≈s ¬s≈t r≈t <span class="ow">=</span> ¬s≈t <span class="o">(</span>trans <span class="o">(</span>symm r≈s<span class="o">)</span> r≈t<span class="o">)</span>
</pre></div>
</div>
<p>In order to specify an instance of <span class="docutils literal"><span class="pre">IsEquivalence</span></span>
in the premises of the theorem,
we can now use our new data type,
extracting the proofs of each of the properties by pattern matching.</p>
<p>When we have to apply the theorem,
say, to prove that it holds for natural numbers,
things become particularly simple:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="nf">theorem-==-equivalence-simple</span> <span class="ow">:</span>
  <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> ¬ <span class="o">(</span>s <span class="ow">==</span> t<span class="o">)</span> <span class="ow">-&gt;</span> ¬ <span class="o">(</span>r <span class="ow">==</span> t<span class="o">)</span>
theorem-==-equivalence-simple
  <span class="ow">=</span> theorem-equivalence-simple theorem-==-is-equivalence
</pre></div>
</div>
</div>
<div class="section" id="record-syntax">
<h2>Record Syntax</h2>
<p>As already mentioned,
pattern matching quickly becomes tedious and error prone
if we have many properties.
It can be very easy to get the ordering wrong.
A logical improvement would be to provide named parameters.
This leads us to record syntax:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="kr">record</span> IsEquivalence2
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="o">(</span>_≈_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="kr">field</span>
    <span class="nf">refl</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ r
    <span class="nf">symm</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> s ≈ r
    <span class="nf">trans</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> s ≈ t <span class="ow">-&gt;</span> r ≈ t
</pre></div>
</div>
<p>Note the differences from our earlier data type definition:
(i) we write &#8220;record&#8221; instead of &#8220;data&#8221;,
(ii) we have moved the constructor&#8217;s arguments into so-called fields,
(iii) we no longer have to specify a constructor.
(In fact, we still could specify a specifically named constructor
if we wanted to, which would then work exactly as the constructor
of our earlier data type, i.e. it might be useful for patter matching.)</p>
<p>The theorem now becomes:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="nf">theorem-==-is-equivalence2</span> <span class="ow">:</span> IsEquivalence2 _==_
theorem-==-is-equivalence2 <span class="ow">=</span> <span class="kr">record</span> <span class="o">{</span>
  refl <span class="ow">=</span> natrefl;
  symm <span class="ow">=</span> theorem-==-symm;
  trans <span class="ow">=</span> theorem-==-trans
  <span class="o">}</span>
</pre></div>
</div>
<p>So, records are constructed with the <span class="docutils literal"><span class="pre">record</span> <span class="pre">{...}</span></span> syntax.
Agda inferred its type from the theorem&#8217;s type signature.
Parameters that are fields can be passed to this constructor
in a named fashion. In particular, the ordering does not matter,
and the intention of the code becomes much clearer.</p>
<p>There is also special syntax for accessing any particular field of a record:
<span class="docutils literal"><span class="pre">&lt;RecordType&gt;.&lt;fieldname&gt;</span> <span class="pre">&lt;instance&gt;</span></span>.
Our theorem thus becomes:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="nf">theorem-equivalence2-simple</span> <span class="ow">:</span>
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span> <span class="ow">-&gt;</span> <span class="o">{</span>_≈_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">}</span> <span class="ow">-&gt;</span> IsEquivalence2 _≈_
  <span class="ow">-&gt;</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> ¬ <span class="o">(</span>s ≈ t<span class="o">)</span> <span class="ow">-&gt;</span> ¬ <span class="o">(</span>r ≈ t<span class="o">)</span>
theorem-equivalence2-simple equiv r≈s ¬s≈t r≈t
  <span class="ow">=</span> ¬s≈t <span class="o">((</span>IsEquivalence2.trans equiv<span class="o">)</span> <span class="o">((</span>IsEquivalence2.symm equiv<span class="o">)</span> r≈s<span class="o">)</span> r≈t<span class="o">)</span>
</pre></div>
</div>
<p>This is less error prone than our earlier theorem,
because we no longer rely on the particular ordering
of the constructor arguments: we no longer rely on pattern matching.
The syntax for field access is still somewhat verbose.
Agda provides us with another trick to simplify this:
for every instance of a record, <span class="docutils literal"><span class="pre">&lt;RecordType&gt;</span> <span class="pre">&lt;instance&gt;</span></span>
corresponds to a module which provides direct access
to the fields of the instance.
We can thus simply write:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="nf">theorem-equivalence2-simple-alt</span> <span class="ow">:</span>
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span> <span class="ow">-&gt;</span> <span class="o">{</span>_≈_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">}</span> <span class="ow">-&gt;</span> IsEquivalence2 _≈_
  <span class="ow">-&gt;</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r ≈ s <span class="ow">-&gt;</span> ¬ <span class="o">(</span>s ≈ t<span class="o">)</span> <span class="ow">-&gt;</span> ¬ <span class="o">(</span>r ≈ t<span class="o">)</span>
theorem-equivalence2-simple-alt equiv r≈s ¬s≈t r≈t
    <span class="ow">=</span> ¬s≈t <span class="o">(</span>trans <span class="o">(</span>symm r≈s<span class="o">)</span> r≈t<span class="o">)</span>
      <span class="kr">where</span> <span class="kr">open</span> IsEquivalence2 equiv
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">open</span></span> command opens a module, that is, brings its declarations
into the current namespace, so we can use <span class="docutils literal"><span class="pre">trans</span></span> and <span class="docutils literal"><span class="pre">symm</span></span>
directly without having to specify the record type and the instance.</p>
<p>The record syntax that we discussed
is heavily used in Agda&#8217;s standard library,
and it is probably time that we started to pay some more attention to it,
in a next post.</p>
</div>
<div class="section" id="reals-revisited">
<h2>Reals Revisited</h2>
<p>To finish this post, here is how our mock real type can be
reimplemented using record syntax. This is entirely equivalent to our
earlier simpler data type syntax, but it leads to code that is much
easier to reuse:</p>
<div class="highlight-agda"><div class="highlight"><pre><span class="kr">module</span> <span class="n">Reals</span> <span class="kr">where</span>

<span class="kr">record</span> IsEquivalence
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="o">(</span>_==_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="kr">field</span>
    <span class="nf">refl</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> r
    <span class="nf">symm</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> s <span class="ow">==</span> r
    <span class="nf">trans</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> s <span class="ow">==</span> t <span class="ow">-&gt;</span> r <span class="ow">==</span> t

<span class="kr">record</span> IsStrictPartialOrder
  <span class="o">{</span>M <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="o">(</span>_==_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="o">(</span>_&lt;_ <span class="ow">:</span> M <span class="ow">-&gt;</span> M <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="kr">field</span>
    <span class="nf">trans&lt;&lt;&lt;</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r &lt; s <span class="ow">-&gt;</span> s &lt; t <span class="ow">-&gt;</span> r &lt; t
    <span class="nf">trans&lt;=&lt;</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r &lt; s <span class="ow">-&gt;</span> s <span class="ow">==</span> t <span class="ow">-&gt;</span> r &lt; t
    <span class="nf">trans=&lt;&lt;</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> s &lt; t <span class="ow">-&gt;</span> r &lt; t

<span class="kr">record</span> IsMockReals
  <span class="o">{</span>ℝ <span class="ow">:</span> <span class="kt">Set</span><span class="o">}</span>
  <span class="o">(</span>_==_ <span class="ow">:</span> ℝ <span class="ow">-&gt;</span> ℝ <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="o">(</span>_&lt;_ <span class="ow">:</span> ℝ <span class="ow">-&gt;</span> ℝ <span class="ow">-&gt;</span> <span class="kt">Set</span><span class="o">)</span>
  <span class="o">(</span>_+_ <span class="ow">:</span> ℝ <span class="ow">-&gt;</span> ℝ <span class="ow">-&gt;</span> ℝ<span class="o">)</span>
  <span class="o">(</span>r0 <span class="ow">:</span> ℝ<span class="o">)</span>
  <span class="o">(</span>r1 <span class="ow">:</span> ℝ<span class="o">)</span>
  <span class="ow">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="kr">field</span>
    <span class="nf">isEquivalence</span> <span class="ow">:</span> IsEquivalence _==_
    <span class="nf">isStrictPartialOrder</span> <span class="ow">:</span> IsStrictPartialOrder _==_ _&lt;_
    <span class="nf">r+r0</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r<span class="o">}</span> <span class="ow">-&gt;</span> <span class="o">(</span>r + r0<span class="o">)</span> <span class="ow">==</span> r
    <span class="nf">symm+</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s<span class="o">}</span> <span class="ow">-&gt;</span> <span class="o">(</span>r + s<span class="o">)</span> <span class="ow">==</span> <span class="o">(</span>s + r<span class="o">)</span>
    <span class="nf">cong+=</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> s <span class="ow">-&gt;</span> <span class="o">(</span>r + t<span class="o">)</span> <span class="ow">==</span> <span class="o">(</span>s + t<span class="o">)</span>
    <span class="nf">cong+&lt;</span> <span class="ow">:</span> <span class="ow">∀</span> <span class="o">{</span>r s t<span class="o">}</span> <span class="ow">-&gt;</span> r &lt; s <span class="ow">-&gt;</span> <span class="o">(</span>r + t<span class="o">)</span> &lt; <span class="o">(</span>s + t<span class="o">)</span>
    <span class="nf">0&lt;1</span> <span class="ow">:</span> r0 &lt; r1

  <span class="kr">open</span> IsEquivalence isEquivalence public
    renaming <span class="o">(</span>refl to refl==; symm to symm==; trans to trans==<span class="o">)</span>

  <span class="kr">open</span> IsStrictPartialOrder isStrictPartialOrder public

  <span class="nf">r0+r</span> <span class="ow">:</span> <span class="o">{</span>r <span class="ow">:</span> ℝ<span class="o">}</span> <span class="ow">-&gt;</span> r <span class="ow">==</span> <span class="o">(</span>r0 + r<span class="o">)</span>
  r0+r <span class="ow">=</span> symm== <span class="o">(</span>trans== symm+ r+r0<span class="o">)</span>

  <span class="nf">thm&lt;+1</span> <span class="ow">:</span> <span class="o">{</span>r <span class="ow">:</span> ℝ<span class="o">}</span> <span class="ow">-&gt;</span> r &lt; <span class="o">(</span>r + r1<span class="o">)</span>
  thm&lt;+1 <span class="ow">=</span> trans&lt;=&lt; <span class="o">(</span>trans=&lt;&lt; r0+r <span class="o">(</span>cong+&lt; <span class="mi">0</span>&lt;1<span class="o">))</span> symm+
</pre></div>
</div>
<p>The new bits are: <span class="docutils literal"><span class="pre">public</span></span>, which re-exports all imported declarations,
<span class="docutils literal"><span class="pre">renaming</span></span> which renames imported declarations,
and the use of declarations directly inside the record
We could have used <span class="docutils literal"><span class="pre">where</span> <span class="pre">open</span> <span class="pre">...</span></span> syntax as well in case we did not
want the theorems to be included as members of the record.
The Agda standard library seems not to put theorems inside records generally;
it may also not always be obvious which record a theorem should belongs to.</p>
<p>An interesting question:
in an arbitrary record,
which parameters should be (unnamed) type parameters,
and which parameters should be (named) field parameters?</p>
</div>
</div>

    <div class="postmeta">
        <div class="author">
            <span>Posted by Matthias C. M. Troffaes</span>
        </div>
        
        
        </div>
    <div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "blowyourmindwithhaskell";    var disqus_identifier = "2014/03/25/using_records_in_agda";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><ul class="related clearfix">
            <li class="left"></li>
            <li class="right"><a href="../../01/15/a_first_attempt_at_real_numbers_in_agda.html">A First Attempt at Real Numbers in Agda</a> &raquo; </li>
        </ul></article><aside class="sidebar"><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="#">Using Records in Agda</a>
        </li><li>
            <a href="../../01/15/a_first_attempt_at_real_numbers_in_agda.html">A First Attempt at Real Numbers in Agda</a>
        </li><li>
            <a href="../../01/13/propositional_logic_in_agda.html">Propositional Logic in Agda</a>
        </li><li>
            <a href="../../01/09/agda__dependent_types__theorem_proving.html">Agda, Dependent Types, Theorem Proving</a>
        </li><li>
            <a href="../../../2013/09/10/typeclasses.html">Typeclasses</a>
        </li><li>
            <a href="../../../2013/08/24/the_list_monad.html">The List Monad</a>
        </li><li>
            <a href="../../../2013/08/21/everything_is_a_function.html">Everything is a Function</a>
        </li><li>
            <a href="../../../2013/08/19/what_is_haskell_.html">What is Haskell?</a>
        </li></ul>
</div>
</section><section><div class="widget" id="searchbox">
    <h1>Search</h1>
    <form action="../../../search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="webfont">L</span></button>
    </form>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container"><footer class="wrapper">&copy; Copyright 2013, Matthias C. M. Troffaes. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>