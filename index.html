

<!DOCTYPE html><!--[if lt IE 7]>      <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:og="http://ogp.me/ns#"
    xmlns:fb="https://www.facebook.com/2008/fbml" class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="A Haskell tutorial">
        <meta name="viewport" content="width=device-width">
        <title>Home &mdash; Blow Your Mind With Haskell</title>
            <link rel="stylesheet" href="_static/normalize.css" type="text/css">
            <link rel="stylesheet" href="_static/sphinx.css" type="text/css">
            <link rel="stylesheet" href="_static/main.css" type="text/css">
            <link rel="stylesheet" href="_static/minimal5.css" type="text/css">
            <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
            <link rel="stylesheet" href="_static/webfont.css" type="text/css">
        <!-- Load modernizr and JQuery -->
        <script src="_static/vendor/modernizr-2.6.2.min.js"></script>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
        <script src="_static/plugins.js"></script>
        <script src="_static/main.js"></script>
        <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.html" /><script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script><script type="text/javascript" src="_static/underscore.js"></script><script type="text/javascript" src="_static/doctools.js"></script><script type="text/javascript" src="_static/disqus.js"></script></head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

      <div id="container">
  <nav>
    <ul><li class="quicklink"><div class="rss">
        <a href="rss.html" title="Subscribe via RSS"><span class="webfont">B</span></a>
    </div></li><li class="main-nav">
          <a href="#">Home</a>
        </li>
      <li class="main-nav">
          <a href="pages/about.html">About</a>
        </li>
      </ul>
  </nav>

  <header>
            <hgroup>
              <h1><a href="#">Blow Your Mind With Haskell</a></h1><h2>Musings of a Haskell Learner</h2></hgroup>
          </header>
      <div class="main-container"><div class="main wrapper clearfix"><article><div class="timestamp postmeta">
            <span>10 September 2013</span>
        </div>
        <div class="section" id="typeclasses">
<h1><a href="2013/09/10/typeclasses.html">Typeclasses</a></h1>
<div class="section" id="polymorphism">
<h2>Polymorphism</h2>
<p>We already saw one way to achieve polymorphism in Haskell:
<a class="reference internal" href="2013/08/21/everything_is_a_function.html#type-variables"><em>type variables</em></a>. For example,
we defined function composition as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">$</span> <span class="n">g</span> <span class="n">x</span>
</pre></div>
</div>
<p>Above, <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span> are generic placeholders
to denote arbitrary types. These are called type variables.</p>
<p>If we think about generalising the monad pattern to general types,
we will quickly find that type variables cannot help us doing so.
Why is that? Well, to use the monad pattern, we need, in essence,
to define a function that binds our monadic structures.
Looking at further examples,
we will very quickly find that we cannot implement this binding operation
in a fully generic way using type variables, because the implementation
of the binding operation is highly tied to the monad structure itself.
In terms of, say, C++, we would like to overload the binding function
for different types.</p>
<p>This is exactly what a <em>typeclass</em> does: it allows us to specify that
a certain type implements certain functions.
The monad typeclass is defined as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Note that we are also required to implement a return function
to embed a type into our monad;
actually, for may examples, this is not really required,
but it can be useful in case a type’s constructors are hidden.
Note that the bind operator <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> and the <span class="docutils literal"><span class="pre">return</span></span> function
are required to be polymorphic, through type variables.</p>
<p>So, in essence,
typeclasses are used to declare that
a particular type implements a particular interface.
For example, the list monad would be implemented as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="n">xs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">$</span> <span class="n">xs</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>Of course, we do not have to type the above ourselves;
Haskell has already done that for us.</p>
</div>
<div class="section" id="a-simple-container-monad">
<h2>A Simple Container Monad</h2>
<p>Let us proceed to a second example of a monad.
Suppose we are carrying out a computation on some value,
but each step of the computation might fail for some reason.
In case of failure, we simply wish to return a dummy value
to signal this failure.</p>
<p>For the time being, let us use a list for this purpose:
an empty list denotes a failed computation, and a non-empty list
of length one denotes successful computation,
with the value it stores being the value computed so far.</p>
<p>As an example of computation, we will parse three digits into an
integer.
A first challenge is to convert a single character into a numerical value.
For this we use the <span class="docutils literal"><span class="pre">ord</span></span> function from the <span class="docutils literal"><span class="pre">Data.Char</span></span> module:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Char</span>
</pre></div>
</div>
<p>We will construct our parser by chaining. A single step of the algorithm
consists of taking a character from the front of a string
(we could also take it from the back, but Haskell encourages
it the other way around), trying to convert it to an integer,
and returning that integer along with the remainder of the characters
still to convert. So, ideally, we would like our function signature to be:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
</pre></div>
</div>
<p>Two problems still to solve are:
(i) how to deal with error conditions, and
(ii) how to allow this function to be recursively “eat” characters.
We change the function signature somewhat to accommodate both issues:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])]</span>
</pre></div>
</div>
<p>Two things have happened: we have written the function
to take just a single argument, namely, a tuple of <span class="docutils literal"><span class="pre">Int</span></span> and <span class="docutils literal"><span class="pre">[Char]</span></span>.
This will simplify chaining: suppose we have eaten a character
and are left with a remaining string, then we can simply call
the function again to get the next digit with its remaining string, and so on.
The second change is that the function now returns a list,
so an empty list can signal an error condition,
and a single element list can signal successful parsing.</p>
<p>Here is the full implementation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])]</span>
<span class="nf">getdigit</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">getdigit</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="ow">=</span> <span class="p">[(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">xs</span><span class="p">)]</span>
  <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="kt">[]</span>
  <span class="kr">where</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>
</pre></div>
</div>
<p>In case of invalid input (empty string, or non-numerical character),
the function simply returns an empty string.
If the input is valid, then the function multiplies the result so far by 10,
and adds the parsed digit to that result;
it also returns the remaining characters.</p>
<p>How can we now parse, say, a three-digit integer?
The list monad helps us out:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getint</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])]</span>
<span class="nf">getint</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">getdigit</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit</span>
</pre></div>
</div>
<p>That looks rather elegant, but what is going on here?</p>
<p>Remember what the list monad does: it takes a list, applies a function
to all elements of that list, and then concatenates the resulting
elements of that list. Let us analyse this process in the above code.
First, we start with <span class="docutils literal"><span class="pre">getdigit</span> <span class="pre">(0,</span> <span class="pre">xs)</span></span>.
If, on the one hand,
the input <span class="docutils literal"><span class="pre">xs</span></span> is empty, or has an invalid first character,
then we end up with an empty list.
If, on the other hand,
the input <span class="docutils literal"><span class="pre">xs</span></span> starts with a valid character,
then we get a list containing the value of that character,
along with the tail of <span class="docutils literal"><span class="pre">xs</span></span>, i.e. all characters still to process.</p>
<p>The monad operation <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> will then apply <span class="docutils literal"><span class="pre">getdigit</span></span>
to all elements of the list we just obtained—remember that this
list is either empty, or contains exactly one element.
If that list was empty, <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> will just return an empty list again
without even calling <span class="docutils literal"><span class="pre">getdigit</span></span>.
If that list contained one element,
it will multiply the original result by 10, add the newly processed digit
to the result, and return a list containing one pair,
namely the result and the remaining characters.
If at this stage, parsing fails, an empty list is produced.</p>
<p>Rinse and repeat.</p>
</div>
<div class="section" id="maybe">
<h2>Maybe</h2>
<p>Using a list to keep track of a failure mode is somewhat contorted:
we are using a cannon to shoot a fly.
Haskell provides a simpler data structure just for the purpose
of storing so-called <em>optional</em> values:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<p>Semantically, a <span class="docutils literal"><span class="pre">Maybe</span></span> is just like a list with at most one element.
Its monad implementation is somewhat simpler than that of lists:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
</pre></div>
</div>
<p>The full implementation becomes:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">getdigit2</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">getdigit2</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="kt">Nothing</span>
  <span class="kr">where</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>

<span class="nf">getint2</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">getint2</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">getdigit2</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit2</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit2</span>
</pre></div>
</div>
<p>This is obviously very similar to our list implementation.
The main difference is that the intent of the code has become clearer
due to the explicit use of <span class="docutils literal"><span class="pre">Maybe</span></span>, <span class="docutils literal"><span class="pre">Nothing</span></span>, and <span class="docutils literal"><span class="pre">Just</span></span>.</p>
</div>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Matthias C. M. Troffaes</span>
        </div>
        
        
        <div class="comments">
            <a href="http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/09/10/typeclasses.html#disqus_thread" data-disqus-identifier="2013/09/10/typeclasses">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>24 August 2013</span>
        </div>
        <div class="section" id="the-list-monad">
<h1><a href="2013/08/24/the_list_monad.html">The List Monad</a></h1>
<p>In the last post, we briefly looked at functions.
Today, we will use our learnings
to investigate a first simple example of monads,
namely, lists.</p>
<p>Lists are as fundamental to Haskell as functions.
Indeed, because everything is a function in Haskell,
you may have wondered how one writes loops in such language.
In a purely functional language,
loops are naturally translated to operations on lists.</p>
<div class="section" id="list-syntax">
<h2>List Syntax</h2>
<p>First, some syntax. The empty list is denoted as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">[]</span>
</pre></div>
</div>
<p>Lists can, obviously, contain as many elements as we want.
In fact, in Haskell, a list can even take any countable number of elements.
This is possible because Haskell is lazy.
To compare with Python, lists are like Python generators,
which can also go on to countable infinity.
Finite lists are denoted as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
</pre></div>
</div>
<p>In Haskell, a list consisting of characters is a <em>string</em>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="n">'h'</span><span class="p">,</span><span class="n">'e'</span><span class="p">,</span><span class="n">'l'</span><span class="p">,</span><span class="n">'l'</span><span class="p">,</span><span class="n">'o'</span><span class="p">]</span>
</pre></div>
</div>
<p>Because this notation is rather heavy,
we can write the above list also as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="s">&quot;hello&quot;</span>
</pre></div>
</div>
<p>which is simply syntactic sugar.</p>
<p>The arithmetic progression, say, starting at 5, with step size 2, and
ending at 21, is denoted as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="o">..</span><span class="mi">21</span><span class="p">]</span>
</pre></div>
</div>
<p>We can also denote infinite arithmetic progressions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="o">..</span><span class="p">]</span>
</pre></div>
</div>
<p>In many (or perhaps most?) languages, the fundamental operation to
extend lists is appending, that is, extending at the end of the
list—for example, in Python, it is very natural to use the <span class="docutils literal"><span class="pre">+=</span></span>
operator.
In Haskell however, <em>prepending</em> is the fundamental operation to
extend lists. The reason for this is straightforward: if you allow infinite
lists, prepending is the only sensible extension operator.
The <span class="docutils literal"><span class="pre">:</span></span> (colon) operator denotes prepend:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>How do we denote lists in type signatures? Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">func</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">func</span> <span class="n">xs</span> <span class="ow">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">sum</span> <span class="n">xs</span>
</pre></div>
</div>
<p>So, <span class="docutils literal"><span class="pre">[Int]</span></span> denote a list of <span class="docutils literal"><span class="pre">Int</span></span> elements.
Observe that the argument of <span class="docutils literal"><span class="pre">func</span></span> is called <span class="docutils literal"><span class="pre">xs</span></span>, rather than <span class="docutils literal"><span class="pre">x</span></span>.
It is a useful convention in Haskell code to denote list variables by
<span class="docutils literal"><span class="pre">xs</span></span>, <span class="docutils literal"><span class="pre">ys</span></span>, and so on,
and to denote their elements by <span class="docutils literal"><span class="pre">x</span></span>, <span class="docutils literal"><span class="pre">y</span></span>, and so on.</p>
<p>In Haskell, all of a list’s elements must be of the same type.
For example, we <strong>cannot</strong> write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">'a'</span><span class="p">,</span><span class="s">&quot;xyz&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="comprehension">
<h2>Comprehension</h2>
<p>There is one more notation for lists which is enormously useful:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span>
              <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="n">n</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="n">n</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>This will give you all numbers, less than 15,
satisfying the conditions of Fermat’s equation <span class="formula"><i>x</i><sup><i>n</i></sup> + <i>y</i><sup><i>n</i></sup> = <i>z</i><sup><i>n</i></sup></span>
;
for the curious, the answer is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">13</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">15</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note that <span class="formula"><i>n</i></span>
 is never larger than 2,
per <a class="reference external" href="http://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem">Fermat’s famous last theorem</a>.
Here is how you could ask Haskell to try to prove the theorem:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="p">[</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span>
                   <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="n">n</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="n">n</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>The calculation is still running on my machine—in fact, it will never end,
because Haskell will simply use brute force,
which is of course problematic
when there are infinitely many cases to consider.
In the above, the function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>returns <span class="docutils literal"><span class="pre">True</span></span> if its list argument is empty—remember
that <span class="docutils literal"><span class="pre">a</span></span> is a type variable,
so this function is polymorphic and will work for lists of any type.</p>
<p>Anyway, let us stop this brief digression and get back to topic: monads!</p>
</div>
<div class="section" id="a-poor-man-s-monad">
<h2>A Poor Man’s Monad</h2>
<p>One way to explain monads, is to try to implement
list comprehension by ourselves, using just functions,
aiming to get as close as possible to the list comprehension syntax.
For this purpose, let us investigate a very simple example,
and try to rewrite:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>which results in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">,</span><span class="mi">30</span><span class="p">]</span>
</pre></div>
</div>
<p>First, let us tackle each of the parts separately,
namely <span class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">[1,2,3]</span></span>, <span class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">[-x,x]</span></span>, and <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">3</span></span>.
Can we rewrite these as functions?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcx</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcx</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="nf">funcy</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcy</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

<span class="nf">funcfinal</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcfinal</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that we do not actually need <span class="docutils literal"><span class="pre">funcx</span></span>—we introduce it here
merely for the sake of symmetry. The important observation is
that all these functions produce lists.
If we may get slightly ahead of ourselves,
in light of general monad theory,
what matters here is that all these functions
produce <em>containers</em> of the same <em>form</em>.</p>
<p>Next, we need a function to combine <span class="docutils literal"><span class="pre">funcx</span></span>, <span class="docutils literal"><span class="pre">funcy</span></span>, and <span class="docutils literal"><span class="pre">funcfinal</span></span>.
Specifically, we wish to <em>bind</em> the outcome of <span class="docutils literal"><span class="pre">funcx</span></span>
to the input of the function <span class="docutils literal"><span class="pre">funcy</span></span>, and then to <em>bind</em>
the outcome of both of these to <span class="docutils literal"><span class="pre">funcfinal</span></span>.
Here is what you might write in a possible attempt:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">bind</span> <span class="n">zs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">$</span> <span class="n">zs</span>
</pre></div>
</div>
<p>In the above, <span class="docutils literal"><span class="pre">map</span></span> applies a function to every element of a list:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">map</span> <span class="n">funcy</span> <span class="o">$</span> <span class="n">funcx</span>
</pre></div>
</div>
<p>gives:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>The function <span class="docutils literal"><span class="pre">concat</span></span> concatenates this list of lists. Consequently:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">funcx</span> <span class="n">funcy</span>
</pre></div>
</div>
<p>gives:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>This is not exactly the result we want,
but we are clearly getting close:
we already have a list with six elements.
The elements are <span class="docutils literal"><span class="pre">y</span></span> rather than <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">3</span></span>,
because we have not yet used <span class="docutils literal"><span class="pre">funcfinal</span></span>.
Can we use <span class="docutils literal"><span class="pre">bind</span></span> to combine <span class="docutils literal"><span class="pre">funcy</span></span> and <span class="docutils literal"><span class="pre">funcfinal</span></span>?
Of course! For instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="p">(</span><span class="n">funcy</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">funcfinal</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>will give us:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>which is the desired result, for <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></span>.
The only remaining problem is to feed all values for <span class="docutils literal"><span class="pre">x</span></span>
into this expression:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind2</span> <span class="n">f1</span> <span class="n">f2</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">bind</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">f2</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>(The type signature is rather complex, so we have omitted it here.)
To get the final result, we thus apply <span class="docutils literal"><span class="pre">bind</span></span> twice:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">funcx</span> <span class="o">$</span> <span class="n">bind2</span> <span class="n">funcy</span> <span class="n">funcfinal</span>
</pre></div>
</div>
<p>This is about as close as we can get to the original expression:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>where
<span class="docutils literal"><span class="pre">funcx</span></span> represents <span class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">[1,2,3]</span></span>,
<span class="docutils literal"><span class="pre">funcy</span></span> represents <span class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">[x,-x]</span></span>, and
<span class="docutils literal"><span class="pre">funcfinal</span></span> represents <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">3</span></span>.
The <span class="docutils literal"><span class="pre">bind</span></span> and <span class="docutils literal"><span class="pre">bind2</span></span> functions are merely glue.</p>
<p>If you followed this far, congratulations!!
You may not realize it yet, but you now know in essence what a monad is.
A monad is a container, along with a higher order function
which binds functions that operate on these containers.
Everything else about monads in Haskell comes down to:</p>
<ol class="arabic simple">
<li>adding syntactic sugar to remove the boilerplate in the above code, and</li>
<li>generalizing from <span class="docutils literal"><span class="pre">[Int]</span></span> lists to arbitrary containers.</li>
</ol>
<p>Yippikayee!</p>
</div>
<div class="section" id="syntactic-sugar">
<h2>Syntactic Sugar</h2>
<p>The aim of this section is
to simplify the structure of our monad code, step by step.</p>
<div class="section" id="infix-notation">
<h3>Infix Notation</h3>
<p>The first thing we can do is rewrite the glue in infix notation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcx</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="n">funcy</span> <span class="p">`</span><span class="n">bind2</span><span class="p">`</span> <span class="n">funcfinal</span><span class="p">)</span>
</pre></div>
</div>
<p>For any function <span class="docutils literal"><span class="pre">f</span></span> in Haskell:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="p">`</span><span class="n">f</span><span class="p">`</span> <span class="n">y</span>
</pre></div>
</div>
<p>is just a shorthand notation for:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="n">y</span>
</pre></div>
</div>
<p>Backticked functions are left-associative.
In the above, we are using the operators in a right-associative way,
thus we need brackets to denote the order of operation.</p>
</div>
<div class="section" id="lambda-functions">
<h3>Lambda Functions</h3>
<p>To get one more step closer to list comprehension notation,
we would like to get rid of the helper functions.
For this purpose, we can use so-called lambda functions,
which allow us to define anonymous functions directly into our expressions.
Note that the use of lambda functions is somewhat frowned upon,
and are generally only used for very simple functions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">((</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="p">`</span><span class="n">bind2</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>In fact, with lambda functions, we can also get rid of <span class="docutils literal"><span class="pre">bind2</span></span>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])))</span>
</pre></div>
</div>
<p>Oh dear, what has happened here?
Let us look at the unsugared version of this code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">funcx</span> <span class="n">funcxy</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcxy</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">bind</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>or equivalently:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcxy'</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">bind</span> <span class="p">(</span><span class="n">funcy</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">funcfinal</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>It now becomes clear that this is entirely equivalent to the original code,
simply by observing that we could also have written:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcxy''</span> <span class="ow">=</span> <span class="n">bind2</span> <span class="n">funcy</span> <span class="n">funcfinal</span>
</pre></div>
</div>
<p>Note that our full code is now down to two lines: a definition of <cite>bind</cite>,
(which is highly generic: we can reuse it for any list comprehension),
and the comprehension itself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">zs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">$</span> <span class="n">zs</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])))</span>
</pre></div>
</div>
<p>We can omit the brackets around lambda definitions, because
the body of the lambda extends as far to the right as possible without hitting
an unbalanced parenthesis <a class="footnote-reference" href="#id2" id="id1">[1]</a>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>We got rid of all brackets,
and this <em>almost</em> looks like our list comprehension.</p>
</div>
<div class="section" id="the-operator">
<h3>The <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> Operator</h3>
<p>Because the <span class="docutils literal"><span class="pre">bind</span></span> operation is so generically useful
for arbitrary list comprehensions,
Haskell implements an <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> operator for us,
which behaves just like our <span class="docutils literal"><span class="pre">bind</span></span>.
We get:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>We note that, in this example,
the infix notation, along with the lambda notation,
is absolutely indispensible to make for readable code.
To convince yourself, compare with the prefix notation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">bind</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])))</span>
</pre></div>
</div>
<p>or with fewer brackets:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>which, although perhaps more explicit, may feel less natural.</p>
</div>
<div class="section" id="do-notation-and-the-operator">
<h3>Do Notation and the <span class="docutils literal"><span class="pre">&lt;-</span></span> Operator</h3>
<p>For large list comprehensions, keeping everything on a single line
becomes tedious. Instead, we can write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>where it is <strong>very important to remember that
the body of ``-&gt;`` extends to the right as far as logically possible</strong>,
i.e. with brackets, our code is equivalent to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
    <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
        <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>Perhaps, you will find that this is already obscure enough.
Nevertheless, Haskell allows you to take this yet one step further,
with a so-called do block.
A do block allows us to replace <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> operators with
newlines and some sort of ‘reverse lambda notation’:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
   <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>The only remaining touch we can give this code is to use Haskell’s
<span class="docutils literal"><span class="pre">return</span></span> function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">return</span></span> function transforms a value into a container
(or, a monad, if you like), and for lists, it is defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>This now looks suspiciously similar to code from an imperative language,
for instance the following in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">3</span>
</pre></div>
</div>
<p>It is tempting, yet flawed,
to think of do blocks as a sequence of imperative statements.
Indeed, Haskell may evaluate expressions in any order it wants,
and is only constrained by data flow. For example, in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
   <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>there is no guarantee whatsoever that Haskell will evaluate <span class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></span>
before <span class="docutils literal"><span class="pre">[9,10]</span></span>. For all we know,
Haskell might even evaluate them in parallel.</p>
</div>
</div>
<div class="section" id="the-monad-typeclass">
<h2>The Monad Typeclass</h2>
<p>The do notation does not only exist for lists, but applies to any monad.
It is crucial to realize that
<strong>the ``&gt;&gt;=`` operator determines how a do block is evaluated</strong>,
as do blocks are simply a fancy way of rewriting
a <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span>-separated chain of expressions.
In fact, any container type
which implements <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> and <span class="docutils literal"><span class="pre">return</span></span> is a monad.
We have not yet seen
how Haskell can overload functions to take arbitrary types.
This is done through Haskell’s typeclasses.</p>
<p>We will cover typeclasses in a next post,
along with more monad examples.</p>
</div>
<div class="section" id="something-to-blow-your-mind">
<h2>Something to Blow Your Mind</h2>
<ol class="arabic">
<li><p class="first">Our attempt at proving Fermat’s theorem using Haskell
leads to a never ending evaluation,
quite logically so.</p>
<p>Explain why:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="p">[</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span>
                 <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>might not end either (depending on the details of the compiler)
although the list is non-empty, but:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="p">[</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="p">],</span>
                 <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>might be evaluated in finite time
(again depending on the details of the compiler).</p>
</li>
<li><p class="first">Fermat’s problem involved filtering,
but our poor man’s implementation did not implement filtering.
What extra operations do we need for our list monad
to gain filtering ability?</p>
<p>How could you abstract this to apply to general monads?</p>
<p>Hint. Analyze the following code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">filt</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">filt</span> <span class="n">cond</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">cond</span> <span class="kr">then</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="kr">else</span> <span class="kt">[]</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="o">..</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">filt</span> <span class="p">(</span><span class="n">odd</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://stackoverflow.com/questions/11237076/haskell-precedence-lambda-and-operator">http://stackoverflow.com/questions/11237076/haskell-precedence-lambda-and-operator</a></td></tr>
</tbody>
</table>
</div>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Matthias C. M. Troffaes</span>
        </div>
        
        
        <div class="comments">
            <a href="http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/24/the_list_monad.html#disqus_thread" data-disqus-identifier="2013/08/24/the_list_monad">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>21 August 2013</span>
        </div>
        <div class="section" id="everything-is-a-function">
<h1><a href="2013/08/21/everything_is_a_function.html">Everything is a Function</a></h1>
<div class="section" id="monads-and-the-magic-blob">
<h2>Monads and The Magic Blob</h2>
<p>Everyone who starts learning Haskell eventually hits monads.
In fact, it ought to be the first thing to start with in Haskell:
remember how any Haskell program essentially does one thing, namely
evaluating the <span class="docutils literal"><span class="pre">main</span></span> function?
Guess what <span class="docutils literal"><span class="pre">main</span></span> returns: yes, indeed, a monad.</p>
<p>Many (though certainly not all) tutorials I came across
start with treating monads—specifically, the IO monad—as
some kind of a magical blob.
In retrospect, now that I <em>think</em> to have an at least somewhat
sufficiently accurate understanding of
what monads do, and what role they play in functional languages,
it makes sense to me to try to understand monads first,
before diving into the IO monad magic.</p>
<p>So, my aim is to try to explain in the next few posts how monads work
in a pure functional language,
and how they allow you to refactor your code to be more beautiful—because
that is what Haskell is all about, beautiful code!
Apparently, monads are <em>also</em> useful for functions that have side effects,
i.e. functions whose result
does not depend only on the value of their arguments.
Once we have a good understanding of what monads are,
our plan is to look at the implementation of the IO monad,
to finally understand the magic.</p>
</div>
<div class="section" id="functions">
<h2>Functions</h2>
<p>Before we look at monads,
it is useful to reflect on how Haskell works with functions,
and how it provides really convenient notation
for combining simple functions together to make up really complex functions.
That is the main purpose of the current post.</p>
<p>First, how do we denote functions?
In Haskell, functions have a name, and one argument.
Yes, all functions have a single argument—we will see in a bit how we
can fake functions with multiple arguments.
It is a good habit, although not necessary, to annotate your functions
with a so-called type signature:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">increment</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>In the above, <span class="docutils literal"><span class="pre">Int</span></span> is simply the name of the type for integers in Haskell.
The code declares the fact that the function, named <span class="docutils literal"><span class="pre">increment</span></span>,
takes an integer, and returns an integer.
Once we have this, we can define the function itself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">increment</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The left hand side denotes the function name (<span class="docutils literal"><span class="pre">increment</span></span>)
and its argument (<span class="docutils literal"><span class="pre">x</span></span>).
Note that we do not need to use brackets for the function argument:
a space denotes function application.
This may seem a bit weird at first,
but one gets used it quite quickly:
it makes for neat code.</p>
<p>The right hand side denotes the expression used to evaluate the function,
namely <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span>, which does what you expect.
We already have something weird here: surely, addition is a function too.
How can we write <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> if every function takes just a single argument?
And why is the function, <span class="docutils literal"><span class="pre">+</span></span>, denoted in between of its arguments?
Well, there are two things going on:</p>
<ul>
<li><p class="first"><span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> is just an alternative notation for <span class="docutils literal"><span class="pre">((+)</span> <span class="pre">x)</span> <span class="pre">1</span></span>.</p>
</li>
<li><p class="first">As the notation in the previous point already suggests,
<span class="docutils literal"><span class="pre">(+)</span></span> is <em>a function which returns another function</em>:
<a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>The brackets around the plus symbol
distinguish the <em>infix</em> notation
<span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> from the <em>prefix</em> notation <span class="docutils literal"><span class="pre">((+)</span> <span class="pre">x)</span> <span class="pre">1</span></span>.</p>
</li>
</ul>
<p>So, <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> first evaluates <span class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></span>,
which is a function with type signature <span class="docutils literal"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></span>.
Consequently, we apply this function to the argument <span class="docutils literal"><span class="pre">1</span></span>,
to get an integer back.
To make the confusion complete,
observe that we can also denote <span class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></span> as <span class="docutils literal"><span class="pre">(x+)</span></span>.
Cool.</p>
<p>Here is the full code,
which you can save as <span class="docutils literal"><span class="pre">test.hs</span></span> and run with <span class="docutils literal"><span class="pre">runghc</span> <span class="pre">test.hs</span></span>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">increment</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">increment</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">increment</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>The type signature of <span class="docutils literal"><span class="pre">main</span></span> is a bit strange: main takes no arguments,
and returns something that has type <span class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></span>.
In fact, <span class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></span> is a monad.
For now, suffice it to say that
to get an IO monad out of some result, we can use the <span class="docutils literal"><span class="pre">print</span></span> function.
Coincidently, <span class="docutils literal"><span class="pre">print</span></span> will also print its argument to the screen,
which is rather convenient.</p>
<p>A few conventions help us with reducing bracket bloat.</p>
<ol class="arabic">
<li><p class="first">The mapping operator <span class="docutils literal"><span class="pre">-&gt;</span></span> in type signatures is right-associative,
so we can write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Space (for function application) is left-associative,
so we can write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span> <span class="mi">1</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first">Space (for function application)
has higher precedence than any other operator.</p>
</li>
</ol>
<p>Note that, earlier, we put brackets around <span class="docutils literal"><span class="pre">increment</span> <span class="pre">5</span></span>
to apply its outcome to the <span class="docutils literal"><span class="pre">print</span></span> function. Had we omitted those brackets,
as in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="n">increment</span> <span class="mi">5</span>
</pre></div>
</div>
<p>then the compiler would have interpreted this as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="p">(</span><span class="n">print</span> <span class="n">increment</span><span class="p">)</span> <span class="mi">5</span>
</pre></div>
</div>
<p>due to the left-associativity of the space operator
(as function application),
which is obviously wrong.
In fact, Haskell will give you a compile error on such code,
because the expression fails the type checks.
Indeed, type checks do prevent a rather frequent cause
of sometimes hard to track bugs;
that is why those type signatures are especially important.</p>
<p>Anyway, with this knowledge, we can now for instance define:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">affine</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">affine</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span>
<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two more infix operators which help us with readability.</p>
<p>First, the <span class="docutils literal"><span class="pre">$</span></span> operator denotes function application,
so it is identical to the space operator,
with the only difference that <span class="docutils literal"><span class="pre">$</span></span> has very low precedence
and is right-associative,
whereas space has very high precedence
and is left-associative.
Thus, we can simplify the last line and write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">$</span> <span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Finally, the <span class="docutils literal"><span class="pre">.</span></span> operator denotes function composition.
Here is its definition:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">$</span> <span class="n">g</span> <span class="n">x</span>
</pre></div>
</div>
<p id="type-variables">In the above, <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span>, are generic placeholders
for any type our heart desires; we say that <span class="docutils literal"><span class="pre">.</span></span> is polymorphic,
and <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span> are called <em>type variables</em>.
They are similar to template arguments in C++.</p>
<p><span class="docutils literal"><span class="pre">.</span></span> has higher precedence than <span class="docutils literal"><span class="pre">$</span></span>, but lower precedence
than space.
Function composition is associative, so if we chain functions together
through composition, there is no need to write brackets to denote
the order of composition.</p>
</div>
<div class="section" id="something-to-blow-your-mind">
<h2>Something to Blow Your Mind</h2>
<p>Explain why:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">.</span> <span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">$</span> <span class="mi">3</span>
</pre></div>
</div>
<p>is the same as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">$</span> <span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="section" id="lessons-learned">
<h2>Lessons Learned</h2>
<ul class="simple">
<li>A function that takes multiple arguments can be modelled as a
function which returns another function.</li>
<li>Space is an operator: it applies functions to arguments, and it
is left-associative, which saves us brackets when working with functions
that take multiple arguments.</li>
<li>A dollar <span class="docutils literal"><span class="pre">$</span></span> is like space, but with very low precedence, and it is
right-associative.</li>
<li>A dot <span class="docutils literal"><span class="pre">.</span></span> denotes function composition. It is associative,
and has medium precedence (higher than <span class="docutils literal"><span class="pre">$</span></span>, and actually also
higher than all the usual binary operators, but lower than space).</li>
<li>Mapping operators <span class="docutils literal"><span class="pre">-&gt;</span></span> in type signatures are right-associative, which
saves us brackets, again, when working with functions that take
multiple arguments.</li>
<li>The standard binary infix operators (<span class="docutils literal"><span class="pre">+</span></span>, <span class="docutils literal"><span class="pre">*</span></span>, <span class="docutils literal"><span class="pre">-</span></span>, <span class="docutils literal"><span class="pre">/</span></span>,
and so on) can be used
in prefix notation—i.e. as normal functions—by
surrounding them with brackets.
It is now not clear why this is useful—just take it on faith that
there are plenty of situations where
it is useful to pass these operators as arguments of other functions,
which is made possible through the prefix notation.</li>
<li>A function can be polymorphic through type variables in its type signature.</li>
<li>For now, <span class="docutils literal"><span class="pre">main</span></span> returns magic blob.
For the time being, we will use <span class="docutils literal"><span class="pre">print</span></span> to blobify our final result,
and be happy in our ignorance.</li>
</ul>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Actually, the type signature is <span class="docutils literal"><span class="pre">(+)</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></span>
but let us not get ahead of ourselves.</td></tr>
</tbody>
</table>
</div>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Matthias C. M. Troffaes</span>
        </div>
        
        
        <div class="comments">
            <a href="http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/21/everything_is_a_function.html#disqus_thread" data-disqus-identifier="2013/08/21/everything_is_a_function">Leave a comment</a>
        </div></div><div class="separator post_separator"></div><div class="timestamp postmeta">
            <span>19 August 2013</span>
        </div>
        <div class="section" id="what-is-haskell">
<h1><a href="2013/08/19/what_is_haskell_.html">What is Haskell?</a></h1>
<p>Did you see <a class="reference external" href="http://www.youtube.com/watch?v=Uooh0Y9fC_M">John Carmack’s keynote at QuakeCon 2013</a>?
I was deeply intrigued by his comments about Haskell,
and by his statement that every programmer should learn Haskell
to write more so-called pure functional code,
thereby reducing bugs and increasing productivity.</p>
<p>Apparently, <strong>Haskell is beautiful</strong>.
Everybody says.
More than enough reason for me!
So, last week, I set myself the task to learn Haskell.
I worked through Chapters 1–7 of
<a class="reference external" href="http://book.realworldhaskell.org/read">Real World Haskell</a>
in reasonable depth,
and started scratching the surface of Chapters 8–15.
This post is a brief summary of my experience so far.</p>
<p>Then, first, what is Haskell?
Haskell is a programming language with a particular set of restrictions:</p>
<ol class="arabic simple">
<li>All values are <em>immutable</em> (i.e. <span class="docutils literal"><span class="pre">const</span></span> if you come from C++).
This may seem weird at first, but in fact, it is not as bad as it sounds.</li>
<li>All values are either
<em>data</em>
(integers, characters, but also lists, records, unions, and so on),
or <em>functions</em>.
These values can be composed together to make <em>expressions</em>
(as in any other programming language).
Classes as you may know them from the Object Oriented world
do not exist in Haskell.</li>
<li>The compiler assumes that functions are
<a class="reference external" href="http://en.wikipedia.org/wiki/Pure_function">pure</a>:
if you call the same pure function with the same arguments,
then you will always get the same result back.
In other words, pure functions are functions in a mathematical sense.
For example, <span class="docutils literal"><span class="pre">getch</span></span> is an impure function in C:
its result is not deterministic.</li>
<li>All values are <em>statically typed</em>, that is,
their type is fixed at compile time.</li>
<li>At runtime, a Haskell program simply evaluates the expression
called <span class="docutils literal"><span class="pre">main</span></span>.</li>
<li>Evaluation is <em>lazy</em>, that is, expressions are only evaluated when
their result is required for the evaluation of <span class="docutils literal"><span class="pre">main</span></span>.</li>
<li>There is no specified order in which subexpressions
are evaluated, i.e. the compiler may resolve the evaluation in any
way deemed appropriate (potentially, even in parallel). <a class="footnote-reference" href="#id2" id="id1">[1]</a></li>
</ol>
<p>For someone coming from, say, Python or C++,
some of these restrictions are highly peculiar, specifically,
immutability, laziness,
and execution through evaluation of a single expression.
In more traditional languages,
you essentially tell the computer what to do, step by step.
In Haskell, you specify an expression you want to be evaluated,
and the compiler figures out the steps to arrive at the result.</p>
<p>All in all, the Haskell approach
has a number of important practical implications:</p>
<ol class="arabic simple">
<li>Due to delegating more work to the compiler,
Haskell programs
are typically much shorter than,
say, their equivalent Python/C++/&lt;insert-your-language-here&gt; implementations.</li>
<li>Haskell encourages you to write beautiful code:
due to its emphasis on purity,
there is a natural focus
on hierarchically decomposing the
problem into simple self-contained expressions,
often leading to highly modularized
self-explanatory code.
Surely, that is a good thing!</li>
<li>We cannot completely kick the habit of impurity,
because I/O is an essential aspect of nearly every program!
Nevertheless, at first sight,
non-trivial I/O
with a compiler that expects only pure functions
and immutable data, appears to be difficult, if not impossible.</li>
</ol>
<p>The latter is a bummer.
It is wildly surprising that Haskell can work
with impure functions in a sane way.
To do so, we have to rely on a generic but very useful
system called a <em>monad</em>.
I hope to write a bit more about monads in the next few posts.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is not entirely true.
Some functions guarantee that certain of their arguments
are evaluated first,
even if the evaluation of those arguments is not needed.
The only purpose this serves is
to help the compiler to produce more efficient machine code.
In principle,
a really clever compiler would not need such hints.
Also see:
<a class="reference external" href="http://www.haskell.org/haskellwiki/Performance/Strictness">http://www.haskell.org/haskellwiki/Performance/Strictness</a></td></tr>
</tbody>
</table>
</div>
        <div class="postmeta">
        <div class="author">
            <span>Posted by Matthias C. M. Troffaes</span>
        </div>
        
        
        <div class="comments">
            <a href="http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/19/what_is_haskell_.html#disqus_thread" data-disqus-identifier="2013/08/19/what_is_haskell_">Leave a comment</a>
        </div></div><div class="archive_link">
        <a href="archive.html"> &mdash; Blog Archive &mdash; </a>
    </div></article><aside class="sidebar"><section><div class="widget">
    <h1>Recent Posts</h1>
    <ul><li>
            <a href="2013/09/10/typeclasses.html">Typeclasses</a>
        </li><li>
            <a href="2013/08/24/the_list_monad.html">The List Monad</a>
        </li><li>
            <a href="2013/08/21/everything_is_a_function.html">Everything is a Function</a>
        </li><li>
            <a href="2013/08/19/what_is_haskell_.html">What is Haskell?</a>
        </li></ul>
</div>
</section><section><div class="widget" id="searchbox">
    <h1>Search</h1>
    <form action="search.html" method="get">
        <input type="text" name="q" />
        <button type="submit"><span class="webfont">L</span></button>
    </form>
</div></section></aside></div> <!-- #main --></div> <!-- #main-container -->

        <div class="footer-container"><footer class="wrapper">&copy; Copyright 2013, Matthias C. M. Troffaes. Powered by <a href="http://www.tinkerer.me/">Tinkerer</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.</footer></div> <!-- footer-container -->

      </div> <!--! end of #container --><script type="text/javascript">    var disqus_shortname = "blowyourmindwithhaskell";    disqus_count();</script><!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
    </body>
</html>