<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Blow Your Mind With Haskell - Using Records in Agda</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
        <div id="navigation">
            <a href="../">Home</a>
            <a href="../about.html">About</a>
            <!--<a href="/contact.html">Contact</a>-->
            <a href="../archive.html">Archive</a>
        </div>
        </div>

        <div id="content">
            <h1>Using Records in Agda</h1>

            <div class="info">
    Posted on March 25, 2014
    
        by Matthias C. M. Troffaes
    
</div>

<h2 id="organizing-code">Organizing Code</h2>
<p>In previous posts, we covered some of the basic principles behind Agda. We discussed the use of data types to describe axioms of our theory, and the use of functions to prove theorems from those axioms. Using just data types and functions, however, it is quite hard to recycle properties in a convenient way. For this purpose, Agda provides a special bit of syntax: records.</p>
<p>Essentially, a record is a glorified data type. Glorified in two ways: (i) parameters can have names (called <em>fields</em>), and (ii) we can embed declarations inside records. In this post, we will only discuss the first point, fields.</p>
<p>For example, let us revisit the mock real type that we declared in our earlier post:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℝ : <span class="dt">Set</span> <span class="kw">where</span>
  r0 <span class="ot">:</span> ℝ
  r1 <span class="ot">:</span> ℝ
  <span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; ℝ

<span class="kw">data</span> <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span> <span class="kw">where</span>
  AXrefl== <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> r == r
  AXsymm== <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == r
  AXtrans== <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == t <span class="ot">-&gt;</span> r == t
  AX+0 <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>r + r0<span class="ot">)</span> == r
  AXsymm+ <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>r + s<span class="ot">)</span> == <span class="ot">(</span>s + r<span class="ot">)</span>
  AX+== <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> <span class="ot">(</span>r + t<span class="ot">)</span> == <span class="ot">(</span>s + t<span class="ot">)</span></code></pre>
<p>How can we make this nicer? Well, it would be quite nice if we could somehow seperate the first three axioms that turn <code class="sourceCode agda"><span class="ot">_</span>==<span class="ot">_</span></code> into an equivalence relation. Secondly, there might be many different ways in which we can actually construct an equivalence relation on a type. In fact, we might work with different equivalence relations at the same time. How can we generically say that some arbitrary relation, say <code class="sourceCode agda"><span class="ot">_</span>≈_</code>, is an equivalence relation?</p>
<h2 id="parametric-data-types-in-overdrive">Parametric Data Types in Overdrive</h2>
<p>Well, we could specify the relation itself as a parameter, along with proofs of the properties it needs to satisfy.</p>
<p>Here is one way:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> IsEquivalence
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">(_</span>≈_ <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>

  isEquivalence <span class="ot">:</span>
    <span class="ot">(</span>refl <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ r<span class="ot">)</span>
    <span class="ot">-&gt;</span> <span class="ot">(</span>symm <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> s ≈ r<span class="ot">)</span>
    <span class="ot">-&gt;</span> <span class="ot">(</span>trans <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> s ≈ t <span class="ot">-&gt;</span> r ≈ t<span class="ot">)</span>
    <span class="ot">-&gt;</span> IsEquivalence <span class="ot">_</span>≈_</code></pre>
<p>So, if we can create an instance of the type <code class="sourceCode agda">IsEquivalence</code> for some relation <code class="sourceCode agda"><span class="ot">_</span>≈_</code>, then <code class="sourceCode agda"><span class="ot">_</span>≈_</code> is an equivalence relation. Here is an example of how we might use <code class="sourceCode agda">IsEquivalence</code>:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℕ : <span class="dt">Set</span> <span class="kw">where</span>
  zero <span class="ot">:</span> ℕ
  suc <span class="ot">:</span> ℕ -&gt; ℕ

<span class="kw">data</span> <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">:</span> ℕ -&gt; ℕ -&gt; <span class="dt">Set</span> <span class="kw">where</span>
  natrefl <span class="ot">:</span> <span class="ot">∀ {</span>n<span class="ot">}</span> <span class="ot">-&gt;</span> n == n

theorem-==-symm <span class="ot">:</span> <span class="ot">∀ {</span>n m<span class="ot">}</span> <span class="ot">-&gt;</span> n == m <span class="ot">-&gt;</span> m == n
theorem-==-symm natrefl <span class="ot">=</span> natrefl

theorem-==-trans <span class="ot">:</span> <span class="ot">∀ {</span>n m k<span class="ot">}</span> <span class="ot">-&gt;</span> n == m <span class="ot">-&gt;</span> m == k <span class="ot">-&gt;</span> n == k
theorem-==-trans natrefl natrefl <span class="ot">=</span> natrefl

theorem-==-is-equivalence <span class="ot">:</span> IsEquivalence <span class="ot">_</span>==<span class="ot">_</span>
theorem-==-is-equivalence
  <span class="ot">=</span> isEquivalence natrefl theorem-==-symm theorem-==-trans</code></pre>
<p>Note that in the above example, only reflexivity had to be specified as an axiom of <code class="sourceCode agda"><span class="ot">_</span>==<span class="ot">_</span></code>, and the other properties could be proved from the definition of <code class="sourceCode agda"><span class="ot">_</span>==<span class="ot">_</span></code> (of course this will not be the case in general!).</p>
<p>This is very generic already. Can we do better? What are the problems with the above approach?</p>
<p>An obvious problem occurs if we have to specify many parameters. Whenever we need the it <code class="sourceCode agda">isEquivalence</code> constructor, we also need to specify three proofs. Three is perhaps not that bad, but for structures with many more properties, we might get the ordering of arguments wrong.</p>
<p>The same issue occurs when we want to use <code class="sourceCode agda">IsEquivalence</code> as a premise of a theorem. For example:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ⊥ : <span class="dt">Set</span> <span class="kw">where</span>
¬_ <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span>
¬ A <span class="ot">=</span> A <span class="ot">-&gt;</span> ⊥
theorem-equivalence-simple <span class="ot">:</span>
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">-&gt;</span> <span class="ot">{_</span>≈_ <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">-&gt;</span> IsEquivalence <span class="ot">_</span>≈_
  <span class="ot">-&gt;</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>s ≈ t<span class="ot">)</span> <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>r ≈ t<span class="ot">)</span>
theorem-equivalence-simple
  <span class="ot">(</span>isEquivalence refl symm trans<span class="ot">)</span>
  r≈s ¬s≈t r≈t = ¬s≈t (trans <span class="ot">(</span>symm r≈s) r≈t)</code></pre>
<p>In order to specify an instance of <code class="sourceCode agda">IsEquivalence</code> in the premises of the theorem, we can now use our new data type, extracting the proofs of each of the properties by pattern matching.</p>
<p>When we have to apply the theorem, say, to prove that it holds for natural numbers, things become particularly simple:</p>
<pre class="sourceCode agda"><code class="sourceCode agda">theorem-==-equivalence-simple <span class="ot">:</span>
  <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>s == t<span class="ot">)</span> <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>r == t<span class="ot">)</span>
theorem-==-equivalence-simple
  <span class="ot">=</span> theorem-equivalence-simple theorem-==-is-equivalence</code></pre>
<h2 id="record-syntax">Record Syntax</h2>
<p>As already mentioned, pattern matching quickly becomes tedious and error prone if we have many properties. It can be very easy to get the ordering wrong. A logical improvement would be to provide named parameters. This leads us to record syntax:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">record</span> IsEquivalence2
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">(_</span>≈_ <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  <span class="kw">field</span>
    refl <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ r
    symm <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> s ≈ r
    trans <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> s ≈ t <span class="ot">-&gt;</span> r ≈ t</code></pre>
<p>Note the differences from our earlier data type definition: (i) we write <code class="sourceCode agda"><span class="kw">record</span></code> instead of <code class="sourceCode agda"><span class="kw">data</span></code>, (ii) we have moved the constructor’s arguments into so-called fields, (iii) we no longer have to specify a constructor. (In fact, we still could specify a specifically named constructor if we wanted to, which would then work exactly as the constructor of our earlier data type, i.e. it might be useful for patter matching.)</p>
<p>The theorem now becomes:</p>
<pre class="sourceCode agda"><code class="sourceCode agda">theorem-==-is-equivalence2 <span class="ot">:</span> IsEquivalence2 <span class="ot">_</span>==<span class="ot">_</span>
theorem-==-is-equivalence2 <span class="ot">=</span> <span class="kw">record</span> <span class="ot">{</span>
  refl <span class="ot">=</span> natrefl<span class="ot">;</span>
  symm <span class="ot">=</span> theorem-==-symm<span class="ot">;</span>
  trans <span class="ot">=</span> theorem-==-trans
  <span class="ot">}</span></code></pre>
<p>So, records are constructed with the <code>record {...}</code> syntax. Agda inferred its type from the theorem’s type signature. Parameters that are fields can be passed to this constructor in a named fashion. In particular, the ordering does not matter, and the intention of the code becomes much clearer.</p>
<p>There is also special syntax for accessing any particular field of a record: <code>&lt;RecordType&gt;.&lt;fieldname&gt; &lt;instance&gt;</code>. Our theorem thus becomes:</p>
<pre class="sourceCode agda"><code class="sourceCode agda">theorem-equivalence2-simple <span class="ot">:</span>
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{_</span>≈_ <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> IsEquivalence2 <span class="ot">_</span>≈_
  <span class="ot">-&gt;</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>s ≈ t<span class="ot">)</span> <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>r ≈ t<span class="ot">)</span>
theorem-equivalence2-simple equiv r≈s ¬s≈t r≈t
  <span class="ot">=</span> ¬s≈t ((IsEquivalence2<span class="ot">.</span>trans equiv<span class="ot">)</span> <span class="ot">((</span>IsEquivalence2<span class="ot">.</span>symm equiv<span class="ot">)</span> r≈s) r≈t)</code></pre>
<p>This is less error prone than our earlier theorem, because we no longer rely on the particular ordering of the constructor arguments: we no longer rely on pattern matching. The syntax for field access is still somewhat verbose. Agda provides us with another trick to simplify this: for every instance of a record, <code>&lt;RecordType&gt; &lt;instance&gt;</code> corresponds to a module which provides direct access to the fields of the instance. We can thus simply write:</p>
<pre class="sourceCode agda"><code class="sourceCode agda">theorem-equivalence2-simple-alt <span class="ot">:</span>
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">{_</span>≈_ <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> IsEquivalence2 <span class="ot">_</span>≈_
  <span class="ot">-&gt;</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r ≈ s <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>s ≈ t<span class="ot">)</span> <span class="ot">-&gt;</span> ¬ <span class="ot">(</span>r ≈ t<span class="ot">)</span>
theorem-equivalence2-simple-alt equiv r≈s ¬s≈t r≈t
    <span class="ot">=</span> ¬s≈t (trans <span class="ot">(</span>symm r≈s) r≈t)
      <span class="kw">where</span> <span class="kw">open</span> IsEquivalence2 equiv</code></pre>
<p>The <code class="sourceCode agda"><span class="kw">open</span></code> command opens a module, that is, brings its declarations into the current namespace, so we can use <code class="sourceCode agda">trans</code> and <code class="sourceCode agda">symm</code> directly without having to specify the record type and the instance.</p>
<p>The record syntax that we discussed is heavily used in Agda’s standard library, and it is probably time that we started to pay some more attention to it, in a next post.</p>
<h2 id="reals-revisited">Reals Revisited</h2>
<p>To finish this post, here is how our mock real type can be reimplemented using record syntax. This is entirely equivalent to our earlier simpler data type syntax, but it leads to code that is much easier to reuse:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">module</span> Reals <span class="kw">where</span>

<span class="kw">record</span> IsEquivalence
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">(_</span>==<span class="ot">_</span> <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  <span class="kw">field</span>
    refl <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> r == r
    symm <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == r
    trans <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == t <span class="ot">-&gt;</span> r == t

<span class="kw">record</span> IsStrictPartialOrder
  <span class="ot">{</span>M <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">(_</span>==<span class="ot">_</span> <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">(_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> M <span class="ot">-&gt;</span> M <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  <span class="kw">field</span>
    trans&lt;&lt;&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r &lt; s <span class="ot">-&gt;</span> s &lt; t <span class="ot">-&gt;</span> r &lt; t
    trans&lt;=&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r &lt; s <span class="ot">-&gt;</span> s == t <span class="ot">-&gt;</span> r &lt; t
    trans=&lt;&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s &lt; t <span class="ot">-&gt;</span> r &lt; t

<span class="kw">record</span> IsMockReals
  <span class="ot">{</span>ℝ : <span class="dt">Set</span><span class="ot">}</span>
  <span class="ot">(_</span>==<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">(_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span><span class="ot">)</span>
  <span class="ot">(_</span>+<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; ℝ)
  <span class="ot">(</span>r0 <span class="ot">:</span> ℝ)
  <span class="ot">(</span>r1 <span class="ot">:</span> ℝ)
  <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  <span class="kw">field</span>
    isEquivalence <span class="ot">:</span> IsEquivalence <span class="ot">_</span>==<span class="ot">_</span>
    isStrictPartialOrder <span class="ot">:</span> IsStrictPartialOrder <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">_</span>&lt;<span class="ot">_</span>
    r+r0 <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>r + r0<span class="ot">)</span> == r
    symm+ <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>r + s<span class="ot">)</span> == <span class="ot">(</span>s + r<span class="ot">)</span>
    cong+= <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> <span class="ot">(</span>r + t<span class="ot">)</span> == <span class="ot">(</span>s + t<span class="ot">)</span>
    cong+&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r &lt; s <span class="ot">-&gt;</span> <span class="ot">(</span>r + t<span class="ot">)</span> &lt; <span class="ot">(</span>s + t<span class="ot">)</span>
    0&lt;1 <span class="ot">:</span> r0 &lt; r1

  <span class="kw">open</span> IsEquivalence isEquivalence <span class="kw">public</span>
    <span class="kw">renaming</span> <span class="ot">(</span>refl <span class="kw">to</span> refl==<span class="ot">;</span> symm <span class="kw">to</span> symm==<span class="ot">;</span> trans <span class="kw">to</span> trans==<span class="ot">)</span>

  <span class="kw">open</span> IsStrictPartialOrder isStrictPartialOrder <span class="kw">public</span>

  r0+r <span class="ot">:</span> <span class="ot">{</span>r <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r == <span class="ot">(</span>r0 + r<span class="ot">)</span>
  r0+r <span class="ot">=</span> symm== <span class="ot">(</span>trans== symm+ r+r0<span class="ot">)</span>

  thm&lt;+1 <span class="ot">:</span> <span class="ot">{</span>r <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r &lt; <span class="ot">(</span>r + r1<span class="ot">)</span>
  thm&lt;+1 <span class="ot">=</span> trans&lt;=&lt; <span class="ot">(</span>trans=&lt;&lt; r0+r <span class="ot">(</span>cong+&lt; 0&lt;1<span class="ot">))</span> symm+</code></pre>
<p>The new bits are: <code class="sourceCode agda"><span class="kw">public</span></code>, which re-exports all imported declarations, <code class="sourceCode agda"><span class="kw">renaming</span></code> which renames imported declarations, and the use of declarations directly inside the record We could have used <code class="sourceCode agda"><span class="kw">where</span> <span class="kw">open</span></code> syntax as well in case we did not want the theorems to be included as members of the record. The Agda standard library seems not to put theorems inside records; it may also not always be obvious which record a theorem should belongs to.</p>
<p>An interesting question: in an arbitrary record, which parameters should be (unnamed) type parameters, and which parameters should be (named) field parameters?</p>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
