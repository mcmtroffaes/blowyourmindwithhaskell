<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Blow Your Mind With Haskell - A First Attempt at Real Numbers in Agda</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
        <div id="navigation">
            <a href="../">Home</a>
            <a href="../about.html">About</a>
            <!--<a href="/contact.html">Contact</a>-->
            <a href="../archive.html">Archive</a>
        </div>
        </div>

        <div id="content">
            <h1>A First Attempt at Real Numbers in Agda</h1>

            <div class="info">
    Posted on January 15, 2014
    
        by Matthias C. M. Troffaes
    
</div>

<h2 id="agda-and-axioms">Agda and Axioms</h2>
<p>Verifying proofs that involve real numbers is apparently not obvious in Agda. Real numbers are a mathematician’s bread and butter, so it comes somewhat as a surprise that there is, apparently, not even a standard module for reals. There is for natural numbers. In fact, natural numbers are really simple, just three lines. Defining a type for rational numbers is also reasonably straightforward (in essence, just pick two natural numbers). However, defining a type for the real numbers is far less straightforward, and there seems to be only little information about it. Nevertheless, as it turns out, we have all the ingredients already.</p>
<p>First, some theory. Roughly, there are two ways to go about real numbers. Either, one defines the reals in terms of sets or sequences of rational numbers. Or, one defines the reals as some set along with some operators (notably, addition and multiplication) which satisfy a particular collection of axioms (e.g. <code class="sourceCode agda"><span class="dv">1</span> * x == x</code> and so on).</p>
<p>How will we go about this? When defining the reals in terms of rationals, the “axioms” of the reals need to be proven from the properties of rationals. On the other hand, when defining the reals through axioms, we will have a lot less proving to do, because axioms are precisely statements that are accepted without proof. So, the axiomatic approach seems to be the approach of least effort. Of course, in principle, we should to prove that the axioms are consistent. One way of doing so, is by proving that there is a construction in terms of rationals which satisfies the axioms. Agda allows us to state axioms without proof of consistency. So, we will take the axiomatic approach.</p>
<p>For simplicity, for now, we will not attempt to define the full set of real numbers. Let us focus on a set with just some properties of the reals.</p>
<h2 id="constructing-real-instances">Constructing Real Instances</h2>
<p>First, we declare the constructors of our mock real type:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> ℝ : <span class="dt">Set</span> <span class="kw">where</span>
  r0 <span class="ot">:</span> ℝ
  r1 <span class="ot">:</span> ℝ
  <span class="ot">_</span>+<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; ℝ</code></pre>
<p>(In emacs, you get <code class="sourceCode agda">ℝ</code> by typing <code>\br</code>.)</p>
<p>This says that we can construct reals in three ways: we have two elements: zero and one, and we can also add reals together. Of course, a full definition would also include at least multiplication, possibly along with substraction, division, negation, and so on.</p>
<h2 id="declaring-axioms">Declaring Axioms</h2>
<p>Now, we wish to specify some properties of addition. How do we go about this? Well, for instance, we might like to say that <code class="sourceCode agda">r + r0 == r</code>. We need an equality operator:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span> <span class="kw">where</span>
  AXrefl== <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> r == r
  AXsymm== <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == r
  AXtrans== <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == t <span class="ot">-&gt;</span> r == t
  AX+0 <span class="ot">:</span> <span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>r + r0<span class="ot">)</span> == r
  AXsymm+ <span class="ot">:</span> <span class="ot">∀ {</span>r s<span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>r + s<span class="ot">)</span> == <span class="ot">(</span>s + r<span class="ot">)</span>
  AX+== <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> <span class="ot">(</span>r + t<span class="ot">)</span> == <span class="ot">(</span>s + t<span class="ot">)</span></code></pre>
<p>So, the equality operator <code class="sourceCode agda">==</code> takes two real numbers, and returns a theorem, that is, an instance of <code class="sourceCode agda"><span class="dt">Set</span></code>. In an earlier post, we saw that instances of <code class="sourceCode agda"><span class="dt">Set</span></code> are types, and essentially correspond to theorems. So, <code class="sourceCode agda">r == s</code>, where <code class="sourceCode agda">r</code> and <code class="sourceCode agda">s</code> are instances of <code class="sourceCode agda">ℝ</code>, i.e. real numbers, is a theorem. The theorem <code class="sourceCode agda">r == s</code> is true if there is an instance of this type. So, constructors of <code class="sourceCode agda">==</code> declare theorems which are necessarily true. Therefore, they are axioms of our theory. In the code above, all of the constructors start with “AX” to emphasize that they are axioms.</p>
<p>There is one bit of new syntax here: the forall operator “∀”. The code is fully equivalent to the following more verbose code:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>==<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span> <span class="kw">where</span>
  AXrefl== <span class="ot">:</span> <span class="ot">{</span>r <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r == r
  AXsymm== <span class="ot">:</span> <span class="ot">{</span>r s <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == r
  AXtrans== <span class="ot">:</span> <span class="ot">{</span>r s t <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s == t <span class="ot">-&gt;</span> r == t
  AX+0 <span class="ot">:</span> <span class="ot">{</span>r <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> <span class="ot">(</span>r + r0<span class="ot">)</span> == r
  AXsymm+ <span class="ot">:</span> <span class="ot">{</span>r s <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> <span class="ot">(</span>r + s<span class="ot">)</span> == <span class="ot">(</span>s + r<span class="ot">)</span>
  AX+== <span class="ot">:</span> <span class="ot">{</span>r s t <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> <span class="ot">(</span>r + t<span class="ot">)</span> == <span class="ot">(</span>s + t<span class="ot">)</span></code></pre>
<p>So, <code class="sourceCode agda"><span class="ot">∀ {</span>r<span class="ot">}</span></code> does two things: it declares <code class="sourceCode agda">r</code> to be an optional argument (as you might have guessed from the curly braces, which we already discussed in an earlier post), and it causes the type of <code class="sourceCode agda">r</code> to be inferred from the remainder of the function signature. Agda will complain if it cannot infer the type.</p>
<p>For example, how can Agda know the type in <code class="sourceCode agda"><span class="ot">∀ {</span>r<span class="ot">}</span> <span class="ot">-&gt;</span> r == r</code>? Well, we know that <code class="sourceCode agda"><span class="ot">_</span>==<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span></code>, so in the expression <code class="sourceCode agda">r == r</code>, it must be that <code class="sourceCode agda">r</code> has type <code class="sourceCode agda">ℝ</code>.</p>
<h2 id="a-first-theorem">A First Theorem</h2>
<p>Let us prove a first theorem: <code class="sourceCode agda">r <span class="ot">=</span> <span class="dv">0</span> + r</code>. This follows from <code class="sourceCode agda">AXsymm+</code> (<code class="sourceCode agda"><span class="dv">0</span> + r <span class="ot">=</span> r + <span class="dv">0</span></code>) and <code class="sourceCode agda">AX+0</code> (<code class="sourceCode agda">r + <span class="dv">0</span> <span class="ot">=</span> r</code>), by transitivity (<code class="sourceCode agda">AXtrans ==</code>), as well as symmetry (<code class="sourceCode agda">AXsymm==</code>).</p>
<p>In Agda, this can be written as follows:</p>
<pre class="sourceCode agda"><code class="sourceCode agda">THM0+ <span class="ot">:</span> <span class="ot">{</span>r <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r == <span class="ot">(</span>r0 + r<span class="ot">)</span>
THM0+ <span class="ot">=</span> AXsymm== <span class="ot">(</span>AXtrans== AXsymm+ AX+0<span class="ot">)</span>
<span class="co">-- AXsymm+ AX+0   r0 + r == r + r0 and r + r0 == r</span>
<span class="co">-- AXtrans==      so r0 + r == r</span>
<span class="co">-- AXsymm==       so r == r0 + r</span></code></pre>
<p>Agda resolved all hidden parameters for us. This really simplified the notation. Here is how the same proof looks like with all parameters specified:</p>
<pre class="sourceCode agda"><code class="sourceCode agda">THM0+ <span class="ot">{</span>r<span class="ot">}</span> <span class="ot">=</span> AXsymm== <span class="ot">{</span>r0 + r<span class="ot">}</span> <span class="ot">{</span>r<span class="ot">}</span> <span class="ot">((</span>AXtrans== <span class="ot">{</span>r0 + r<span class="ot">}</span> <span class="ot">{</span>r + r0<span class="ot">}</span> <span class="ot">{</span>r<span class="ot">})</span> <span class="ot">(</span>AXsymm+ <span class="ot">{</span>r0<span class="ot">}</span> <span class="ot">{</span>r<span class="ot">})</span> <span class="ot">(</span>AX+0 <span class="ot">{</span>r<span class="ot">}))</span></code></pre>
<p>This kind of symplicity really helps readability, although it probably also hurts understanding the code to some extent. But it does not really hurt understanding how the proof work: because we can omit all instances of reals, all that is left are the axioms (and theorems, later) that have been applied, and in what order. This provides a nice summary of the proof.</p>
<p>What is amazing here is that it is <em>not</em> a summary. <strong>All variables in the proof can be inferred unambiguously from the axioms and the order in which they are applied.</strong> I am not sure whether this is possible in general (probably not), but it surely is a nice feature of Agda.</p>
<h2 id="another-theorem">Another Theorem</h2>
<p>Here are some axioms for strict inequality:</p>
<pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> <span class="ot">_</span>&lt;<span class="ot">_</span> <span class="ot">:</span> ℝ -&gt; ℝ -&gt; <span class="dt">Set</span> <span class="kw">where</span>
  AXtrans&lt;&lt;&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r &lt; s <span class="ot">-&gt;</span> s &lt; t <span class="ot">-&gt;</span> r &lt; t
  AX&lt;=&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r &lt; s <span class="ot">-&gt;</span> s == t <span class="ot">-&gt;</span> r &lt; t
  AX=&lt;&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r == s <span class="ot">-&gt;</span> s &lt; t <span class="ot">-&gt;</span> r &lt; t
  AX0&lt;1 <span class="ot">:</span> r0 &lt; r1
  AX+&lt;&lt; <span class="ot">:</span> <span class="ot">∀ {</span>r s t<span class="ot">}</span> <span class="ot">-&gt;</span> r &lt; s <span class="ot">-&gt;</span> <span class="ot">(</span>r + t<span class="ot">)</span> &lt; <span class="ot">(</span>s + t<span class="ot">)</span></code></pre>
<p>Let us prove that <code class="sourceCode agda">r &lt; r + <span class="dv">1</span></code>.</p>
<pre class="sourceCode agda"><code class="sourceCode agda">THM&lt;+1 <span class="ot">:</span> <span class="ot">{</span>r <span class="ot">:</span> ℝ} <span class="ot">-&gt;</span> r &lt; <span class="ot">(</span>r + r1<span class="ot">)</span>
THM&lt;+1 <span class="ot">=</span> AX&lt;=&lt; <span class="ot">(</span>AX=&lt;&lt; THM0+ <span class="ot">(</span>AX+&lt;&lt; AX0&lt;1<span class="ot">))</span> AXsymm+
<span class="co">-- AX0&lt;1              0 &lt; 1</span>
<span class="co">-- AX&lt;+ %             so 0 + r &lt; 1 + r</span>
<span class="co">-- AX=&lt;&lt; THM0+ %      so r &lt; 1 + r</span>
<span class="co">-- AX&lt;=&lt; % AXsymm+    so r &lt; r + 1</span></code></pre>
<p>Again, to interpret these proofs, it is useful to first decipher the ordering in which the axioms and theorems are applied. The innermost expression is <code class="sourceCode agda">AX0&lt;1</code>. We start from there and work our way to the outer expression to get to the full proof, as explained in the comments. I used <code>%</code> as a symbol for the expression on the previous line (as in Maple).</p>
<p>Is the sky the limit? There seems nothing preventing us to do the entire real calculus. Let us try this in a next post.</p>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
