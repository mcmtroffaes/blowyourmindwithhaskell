<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Blow Your Mind With Haskell</title>
        <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/</link>
        <description>Musings of a Haskell Learner</description>
        <language>en-us</language>
        <pubDate>Mon, 19 Aug 2013 00:00:00 +0100</pubDate>
        
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/19/what_is_haskell_.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/19/what_is_haskell_.html</guid>
            <title><![CDATA[What is Haskell?]]></title>
            <description><![CDATA[
<div class="section" id="what-is-haskell">
<h1>What is Haskell?</h1>
<p>Did you see <a class="reference external" href="http://www.youtube.com/watch?v=Uooh0Y9fC_M">John Carmack’s keynote at QuakeCon 2013</a>?
I was deeply intrigued by his comments about Haskell,
and by his statement that every programmer should learn Haskell
to write more so-called pure functional code,
thereby reducing bugs and increasing productivity.</p>
<p>Apparently, <strong>Haskell is beautiful</strong>.
Everybody says.
More than enough reason for me!
So, last week, I set myself the task to learn Haskell.
I worked through Chapters 1–7 of
<a class="reference external" href="http://book.realworldhaskell.org/read">Real World Haskell</a>
in reasonable depth,
and started scratching the surface of Chapters 8–15.
This post is a brief summary of my experience so far.</p>
<p>Then, first, what is Haskell?
Haskell is a programming language with a particular set of restrictions:</p>
<ol class="arabic simple">
<li>All values are <em>immutable</em> (i.e. <span class="docutils literal"><span class="pre">const</span></span> if you come from C++).
This may seem weird at first, but in fact, it is not as bad as it sounds.</li>
<li>All values are either
<em>data</em>
(integers, characters, but also lists, records, unions, and so on),
or <em>functions</em>.
These values can be composed together to make <em>expressions</em>
(as in any other programming language).
Classes as you may know them from the Object Oriented world
do not exist in Haskell.</li>
<li>The compiler assumes that functions are
<a class="reference external" href="http://en.wikipedia.org/wiki/Pure_function">pure</a>:
if you call the same pure function with the same arguments,
then you will always get the same result back.
In other words, pure functions are functions in a mathematical sense.
For example, <span class="docutils literal"><span class="pre">getch</span></span> is an impure function in C:
its result is not deterministic.</li>
<li>All values are <em>statically typed</em>, that is,
their type is fixed at compile time.</li>
<li>At runtime, a Haskell program simply evaluates the expression
called <span class="docutils literal"><span class="pre">main</span></span>.</li>
<li>Evaluation is <em>lazy</em>, that is, expressions are only evaluated when
their result is required for the evaluation of <span class="docutils literal"><span class="pre">main</span></span>.</li>
<li>There is no specified order in which subexpressions
are evaluated, i.e. the compiler may resolve the evaluation in any
way deemed appropriate (potentially, even in parallel). <a class="footnote-reference" href="#id2" id="id1">[1]</a></li>
</ol>
<p>For someone coming from, say, Python or C++,
some of these restrictions are highly peculiar, specifically,
immutability, laziness,
and execution through evaluation of a single expression.
In more traditional languages,
you essentially tell the computer what to do, step by step.
In Haskell, you specify an expression you want to be evaluated,
and the compiler figures out the steps to arrive at the result.</p>
<p>All in all, the Haskell approach
has a number of important practical implications:</p>
<ol class="arabic simple">
<li>Due to delegating more work to the compiler,
Haskell programs
are typically much shorter than,
say, their equivalent Python/C++/&lt;insert-your-language-here&gt; implementations.</li>
<li>Haskell encourages you to write beautiful code:
due to its emphasis on purity,
there is a natural focus
on hierarchically decomposing the
problem into simple self-contained expressions,
often leading to highly modularized
self-explanatory code.
Surely, that is a good thing!</li>
<li>We cannot completely kick the habit of impurity,
because I/O is an essential aspect of nearly every program!
Nevertheless, at first sight,
non-trivial I/O
with a compiler that expects only pure functions
and immutable data, appears to be difficult, if not impossible.</li>
</ol>
<p>The latter is a bummer.
It is wildly surprising that Haskell can work
with impure functions in a sane way.
To do so, we have to rely on a generic but very useful
system called a <em>monad</em>.
I hope to write a bit more about monads in the next few posts.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is not entirely true.
Some functions guarantee that certain of their arguments
are evaluated first,
even if the evaluation of those arguments is not needed.
The only purpose this serves is
to help the compiler to produce more efficient machine code.
In principle,
a really clever compiler would not need such hints.
Also see:
<a class="reference external" href="http://www.haskell.org/haskellwiki/Performance/Strictness">http://www.haskell.org/haskellwiki/Performance/Strictness</a></td></tr>
</tbody>
</table>
</div>]]></description>
             <pubDate>Mon, 19 Aug 2013 00:00:00 +0100</pubDate>
        </item>
    
    </channel>
</rss>