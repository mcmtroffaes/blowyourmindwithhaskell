<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Blow Your Mind With Haskell</title>
        <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/</link>
        <description>Musings of a Haskell Learner</description>
        <language>en-us</language>
        <pubDate>Tue, 25 Mar 2014 00:00:00 +0000</pubDate>
        
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/03/25/using_records_in_agda.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/03/25/using_records_in_agda.html</guid>
            <title><![CDATA[Using Records in Agda]]></title>
            <description><![CDATA[<div class="section" id="using-records-in-agda">
<h1>Using Records in Agda</h1>
<div class="section" id="organizing-code">
<h2>Organizing Code</h2>
<p>In previous posts, we covered some of the basic principles behind Agda.
We discussed the use of data types to describe axioms of our theory,
and the use of functions to prove theorems from those axioms.
Using just data types and functions, however,
it is quite hard to recycle properties in a convenient way.
For this purpose, Agda provides a special bit of syntax: records.</p>
<p>Essentially, a record is a glorified data type.
Glorified in two ways:
(i) parameters can have names (called <em>fields</em>), and
(ii) we can embed declarations inside records.
In this post, we will only discuss the first point, fields.</p>
<p>For example, let us revisit the mock real type that we declared in our
earlier post:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data ℝ : Set where
  r0 : ℝ
  r1 : ℝ
  _+_ : ℝ -&gt; ℝ -&gt; ℝ

data _==_ : ℝ -&gt; ℝ -&gt; Set where
  AXrefl== : ∀ {r} -&gt; r == r
  AXsymm== : ∀ {r s} -&gt; r == s -&gt; s == r
  AXtrans== : ∀ {r s t} -&gt; r == s -&gt; s == t -&gt; r == t
  AX+0 : ∀ {r} -&gt; (r + r0) == r
  AXsymm+ : ∀ {r s} -&gt; (r + s) == (s + r)
  AX+== : ∀ {r s t} -&gt; r == s -&gt; (r + t) == (s + t)
</pre></div>
</div>
<p>How can we make this nicer?
Well, it would be quite nice if we could
somehow seperate the first three axioms that turn <span class="docutils literal"><span class="pre">_==_</span></span> into an
equivalence relation.
Secondly, there might be many different ways
in which we can actually construct an equivalence relation on a type.
In fact, we might work with different equivalence relations at the same time.
How can we generically say that some arbitrary relation, say <span class="docutils literal"><span class="pre">_≈_</span></span>,
is an equivalence relation?</p>
</div>
<div class="section" id="parametric-data-types-in-overdrive">
<h2>Parametric Data Types in Overdrive</h2>
<p>Well, we could specify the relation itself as a parameter,
along with proofs of the properties it needs to satisfy.</p>
<p>Here is one way:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data IsEquivalence
  {M : Set}
  (_≈_ : M -&gt; M -&gt; Set)
  : Set where

  isEquivalence :
    (refl : ∀ {r} -&gt; r ≈ r)
    -&gt; (symm : ∀ {r s} -&gt; r ≈ s -&gt; s ≈ r)
    -&gt; (trans : ∀ {r s t} -&gt; r ≈ s -&gt; s ≈ t -&gt; r ≈ t)
    -&gt; IsEquivalence _≈_
</pre></div>
</div>
<p>So, if we can create an instance of the type <span class="docutils literal"><span class="pre">IsEquivalence</span></span>
for some relation <span class="docutils literal"><span class="pre">_≈_</span></span>, then <span class="docutils literal"><span class="pre">_≈_</span></span> is an equivalence relation.
Here is an example of how we might use <span class="docutils literal"><span class="pre">IsEquivalence</span></span>:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data ℕ : Set where
  zero : ℕ
  suc : ℕ -&gt; ℕ

data _==_ : ℕ -&gt; ℕ -&gt; Set where
  natrefl : ∀ {n} -&gt; n == n

theorem-==-symm : ∀ {n m} -&gt; n == m -&gt; m == n
theorem-==-symm natrefl = natrefl

theorem-==-trans : ∀ {n m k} -&gt; n == m -&gt; m == k -&gt; n == k
theorem-==-trans natrefl natrefl = natrefl

theorem-==-is-equivalence : IsEquivalence _==_
theorem-==-is-equivalence
  = isEquivalence natrefl theorem-==-symm theorem-==-trans
</pre></div>
</div>
<p>Note that in the above example,
only reflexivity had to be specified as an axiom of <span class="docutils literal"><span class="pre">_==_</span></span>, and
the other properties could be proved from the definition of <span class="docutils literal"><span class="pre">_==_</span></span>
(of course this will not be the case in general!).</p>
<p>This is very generic already.
Can we do better? What are the problems with the above approach?</p>
<p>An obvious problem occurs if we have to specify
many parameters. Whenever we need
the <span class="docutils literal"><span class="pre">IsEquivalence</span></span> type, or its <span class="docutils literal"><span class="pre">isEquivalence</span></span> constructor,
we also need to specify four parameters
(excluding the hidden parameter <span class="docutils literal"><span class="pre">M</span></span>), namely the relation,
along with the three axioms.
This makes the code hard to read,
and even worse,
we might get the ordering of parameters wrong.
In the above example, we only have three axioms,
but in general, the number of axioms that we may want to work with
simultaneously can become very, very large.</p>
<p>Finally, and perhaps this is the strongest shortcoming of all,
showing already in this very simple example:
using <span class="docutils literal"><span class="pre">IsEquivalence</span></span>
in theorems that require equivalence relations
does not lead to further abstraction and simplification of our code.
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data ⊥ : Set where
¬_ : Set -&gt; Set
¬ A = A -&gt; ⊥
theorem-equivalence-simple :
  {M : Set}
  -&gt; {_≈_ : M -&gt; M -&gt; Set}
  -&gt; IsEquivalence _≈_
  -&gt; ∀ {r s t} -&gt; r ≈ s -&gt; ¬ (s ≈ t) -&gt; ¬ (r ≈ t)
theorem-equivalence-simple
  (isEquivalence refl symm trans)
  r≈s ¬s≈t r≈t = ¬s≈t (trans (symm r≈s) r≈t)
</pre></div>
</div>
<p>In order to specify an instance of <span class="docutils literal"><span class="pre">IsEquivalence</span></span>
in the premises of the theorem,
we can now use our new data type
instead of having to specify proofs of all axioms.</p>
<p>Similarly, it provides with some simplification
when we have to apply the theorem,
say, to prove that it holds for natural numbers:</p>
<div class="highlight-haskell"><div class="highlight"><pre>theorem-==-equivalence-simple :
  ∀ {r s t} -&gt; r == s -&gt; ¬ (s == t) -&gt; ¬ (r == t)
theorem-==-equivalence-simple
  = theorem-equivalence-simple theorem-==-is-equivalence
</pre></div>
</div>
</div>
<div class="section" id="record-syntax">
<h2>Record Syntax</h2>
<p>One downside is that pattern matching will become a bit tedious
if we have many properties.
It can be very easy to get the ordering wrong.
A logical improvement would be to provide named parameters.
This leads us to record syntax:</p>
<div class="highlight-haskell"><div class="highlight"><pre>record IsEquivalence2
  {M : Set}
  (_≈_ : M -&gt; M -&gt; Set)
  : Set where
  field
    refl : ∀ {r} -&gt; r ≈ r
    symm : ∀ {r s} -&gt; r ≈ s -&gt; s ≈ r
    trans : ∀ {r s t} -&gt; r ≈ s -&gt; s ≈ t -&gt; r ≈ t
</pre></div>
</div>
<p>Note the differences from our earlier data type definition:
(i) we write “record” instead of “data”,
(ii) we have moved the constructor’s arguments into so-called fields,
(iii) we no longer have to specify a constructor.
(In fact, we still could specify a specifically named constructor
if we wanted to, which would then work exactly as the constructor
of our earlier data type, i.e. it might be useful for patter matching.)</p>
<p>The theorem now becomes:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">theorem</span><span class="o">-==-</span><span class="n">is</span><span class="o">-</span><span class="n">equivalence2</span> <span class="kt">:</span> <span class="kt">IsEquivalence2</span> <span class="kr">_</span><span class="o">==</span><span class="kr">_</span>
<span class="nf">theorem</span><span class="o">-==-</span><span class="n">is</span><span class="o">-</span><span class="n">equivalence2</span> <span class="ow">=</span> <span class="n">record</span> <span class="p">{</span>
  <span class="n">refl</span> <span class="ow">=</span> <span class="n">natrefl</span><span class="p">;</span>
  <span class="n">symm</span> <span class="ow">=</span> <span class="n">theorem</span><span class="o">-==-</span><span class="n">symm</span><span class="p">;</span>
  <span class="n">trans</span> <span class="ow">=</span> <span class="n">theorem</span><span class="o">-==-</span><span class="n">trans</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>So, records are constructed with the <span class="docutils literal"><span class="pre">record</span> <span class="pre">{...}</span></span> syntax.
Agda inferred its type from the theorem’s type signature.
Parameters that are fields can be passed to this constructor
in a named fashion. In particular, the ordering does not matter,
and the intention of the code becomes much clearer.</p>
<p>There is also special syntax for accessing any particular field of a record:
<span class="docutils literal"><span class="pre">&lt;RecordType&gt;.&lt;fieldname&gt;</span> <span class="pre">&lt;instance&gt;</span></span>.
Our theorem thus becomes:</p>
<div class="highlight-haskell"><div class="highlight"><pre>theorem-equivalence2-simple :
  {M : Set} -&gt; {_≈_ : M -&gt; M -&gt; Set} -&gt; IsEquivalence2 _≈_
  -&gt; ∀ {r s t} -&gt; r ≈ s -&gt; ¬ (s ≈ t) -&gt; ¬ (r ≈ t)
theorem-equivalence2-simple equiv r≈s ¬s≈t r≈t
  = ¬s≈t ((IsEquivalence2.trans equiv) ((IsEquivalence2.symm equiv) r≈s) r≈t)
</pre></div>
</div>
<p>This is less error prone than our earlier theorem,
because we no longer rely on the particular ordering
of the constructor arguments: we no longer rely on pattern matching.
The syntax for field access is still somewhat verbose.
Agda provides us with another trick to simplify this:
for every instance of a record, <span class="docutils literal"><span class="pre">&lt;RecordType&gt;</span> <span class="pre">&lt;instance&gt;</span></span>
corresponds to a module which provides direct access
to the fields of the instance.
We can thus simply write:</p>
<div class="highlight-haskell"><div class="highlight"><pre>theorem-equivalence2-simple-alt :
  {M : Set} -&gt; {_≈_ : M -&gt; M -&gt; Set} -&gt; IsEquivalence2 _≈_
  -&gt; ∀ {r s t} -&gt; r ≈ s -&gt; ¬ (s ≈ t) -&gt; ¬ (r ≈ t)
theorem-equivalence2-simple-alt equiv r≈s ¬s≈t r≈t
    = ¬s≈t (trans (symm r≈s) r≈t)
      where open IsEquivalence2 equiv
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">open</span></span> command opens a module, that is, brings its declarations
into the current namespace, so we can use <span class="docutils literal"><span class="pre">trans</span></span> and <span class="docutils literal"><span class="pre">symm</span></span>
directly without having to specify the record type and the instance.</p>
<p>The record syntax that we discussed
is heavily used in Agda’s standard library,
and it is probably time that we started to pay some more attention to it,
in a next post.</p>
</div>
<div class="section" id="reals-revisited">
<h2>Reals Revisited</h2>
<p>To finish this post, here is how our mock real type can be
reimplemented using record syntax. This is entirely equivalent to our
earlier simpler data type syntax, but it leads to code that is much
easier to reuse:</p>
<div class="highlight-haskell"><div class="highlight"><pre>module Reals where

record IsEquivalence
  {M : Set}
  (_==_ : M -&gt; M -&gt; Set)
  : Set where
  field
    refl : ∀ {r} -&gt; r == r
    symm : ∀ {r s} -&gt; r == s -&gt; s == r
    trans : ∀ {r s t} -&gt; r == s -&gt; s == t -&gt; r == t

record IsStrictPartialOrder
  {M : Set}
  (_==_ : M -&gt; M -&gt; Set)
  (_&lt;_ : M -&gt; M -&gt; Set)
  : Set where
  field
    trans&lt;&lt;&lt; : ∀ {r s t} -&gt; r &lt; s -&gt; s &lt; t -&gt; r &lt; t
    trans&lt;=&lt; : ∀ {r s t} -&gt; r &lt; s -&gt; s == t -&gt; r &lt; t
    trans=&lt;&lt; : ∀ {r s t} -&gt; r == s -&gt; s &lt; t -&gt; r &lt; t

record IsMockReals
  {ℝ : Set}
  (_==_ : ℝ -&gt; ℝ -&gt; Set)
  (_&lt;_ : ℝ -&gt; ℝ -&gt; Set)
  (_+_ : ℝ -&gt; ℝ -&gt; ℝ)
  (r0 : ℝ)
  (r1 : ℝ)
  : Set where
  field
    isEquivalence : IsEquivalence _==_
    isStrictPartialOrder : IsStrictPartialOrder _==_ _&lt;_
    r+r0 : ∀ {r} -&gt; (r + r0) == r
    symm+ : ∀ {r s} -&gt; (r + s) == (s + r)
    cong+= : ∀ {r s t} -&gt; r == s -&gt; (r + t) == (s + t)
    cong+&lt; : ∀ {r s t} -&gt; r &lt; s -&gt; (r + t) &lt; (s + t)
    0&lt;1 : r0 &lt; r1

  open IsEquivalence isEquivalence public
    renaming (refl to refl==; symm to symm==; trans to trans==)

  open IsStrictPartialOrder isStrictPartialOrder public

  r0+r : {r : ℝ} -&gt; r == (r0 + r)
  r0+r = symm== (trans== symm+ r+r0)

  thm&lt;+1 : {r : ℝ} -&gt; r &lt; (r + r1)
  thm&lt;+1 = trans&lt;=&lt; (trans=&lt;&lt; r0+r (cong+&lt; 0&lt;1)) symm+
</pre></div>
</div>
<p>The new bits are: <span class="docutils literal"><span class="pre">public</span></span>, which re-exports all imported declarations,
<span class="docutils literal"><span class="pre">renaming</span></span> which renames imported declarations,
and the use of declarations directly inside the record
We could have used <span class="docutils literal"><span class="pre">where</span> <span class="pre">open</span> <span class="pre">...</span></span> syntax as well in case we did not
want the theorems to be included as members of the record.
The Agda standard library seems not to put theorems inside records generally;
it may also not always be obvious which record a theorem should belongs to.</p>
<p>An interesting question:
in an arbitrary record,
which parameters should be (unnamed) type parameters,
and which parameters should be (named) field parameters?</p>
</div>
</div>]]></description>
             <pubDate>Tue, 25 Mar 2014 00:00:00 +0000</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/01/15/a_first_attempt_at_real_numbers_in_agda.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/01/15/a_first_attempt_at_real_numbers_in_agda.html</guid>
            <title><![CDATA[A First Attempt at Real Numbers in Agda]]></title>
            <description><![CDATA[<div class="section" id="a-first-attempt-at-real-numbers-in-agda">
<h1>A First Attempt at Real Numbers in Agda</h1>
<div class="section" id="agda-and-axioms">
<h2>Agda and Axioms</h2>
<p>Verifying proofs that involve real numbers is apparently not obvious in Agda.
Real numbers are a mathematician’s bread and butter,
so it comes somewhat as a surprise that there is, apparently, not even
a standard module for reals.
There is for natural numbers.
In fact, natural numbers are really simple, just three lines.
Defining a type for rational numbers
is also reasonably straightforward
(in essence, just pick two natural numbers).
However, defining a type for the real numbers is far less straightforward,
and there seems to be only little information about it.
Nevertheless, as it turns out, we have all the ingredients already.</p>
<p>First, some theory.
Roughly, there are two ways to go about real numbers.
Either, one defines the reals
in terms of sets or sequences of rational numbers.
Or, one defines the reals as some set
along with some operators (notably, addition and multiplication)
which satisfy a particular collection of axioms
(e.g. <span class="docutils literal"><span class="pre">1</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span></span> and so on).</p>
<p>How will we go about this?
When defining the reals in terms of rationals,
the “axioms” of the reals need to be proven from the properties of rationals.
On the other hand, when defining the reals through axioms,
we will have a lot less proving to do,
because axioms are precisely statements that are accepted without proof.
So, the axiomatic approach seems to be the approach of least effort.
Of course, in principle, we should to prove that the axioms are consistent.
One way of doing so, is by proving that there is a construction
in terms of rationals which satisfies the axioms.
Agda allows us to state axioms without proof of consistency.
So, we will take the axiomatic approach.</p>
<p>For simplicity, for now,
we will not attempt to define the full set of real numbers.
Let us focus on a set with just some properties of the reals.</p>
</div>
<div class="section" id="constructing-real-instances">
<h2>Constructing Real Instances</h2>
<p>First, we declare the constructors of our mock real type:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data ℝ : Set where
  r0 : ℝ
  r1 : ℝ
  _+_ : ℝ -&gt; ℝ -&gt; ℝ
</pre></div>
</div>
<p>(In emacs, you get <span class="docutils literal"><span class="pre">ℝ</span></span> by typing <span class="docutils literal"><span class="pre">\br</span></span>.)</p>
<p>This says that we can construct reals in three ways:
we have two elements: zero and one, and we can also add reals together.
Of course, a full definition would also include
at least multiplication,
possibly along with substraction, division, negation, and so on.</p>
</div>
<div class="section" id="declaring-axioms">
<h2>Declaring Axioms</h2>
<p>Now, we wish to specify some properties of addition.
How do we go about this?
Well, for instance, we might like to say that <span class="docutils literal"><span class="pre">r</span> <span class="pre">+</span> <span class="pre">r0</span> <span class="pre">==</span> <span class="pre">r</span></span>.
We need an equality operator:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data _==_ : ℝ -&gt; ℝ -&gt; Set where
  AXrefl== : ∀ {r} -&gt; r == r
  AXsymm== : ∀ {r s} -&gt; r == s -&gt; s == r
  AXtrans== : ∀ {r s t} -&gt; r == s -&gt; s == t -&gt; r == t
  AX+0 : ∀ {r} -&gt; (r + r0) == r
  AXsymm+ : ∀ {r s} -&gt; (r + s) == (s + r)
  AX+== : ∀ {r s t} -&gt; r == s -&gt; (r + t) == (s + t)
</pre></div>
</div>
<p>So, the equality operator <span class="docutils literal"><span class="pre">==</span></span> takes two real numbers,
and returns a theorem, that is, an instance of <span class="docutils literal"><span class="pre">Set</span></span>.
In an earlier post, we saw that instances of <span class="docutils literal"><span class="pre">Set</span></span> are types,
and essentially correspond to theorems.
So, <span class="docutils literal"><span class="pre">r</span> <span class="pre">==</span> <span class="pre">s</span></span>, where <span class="docutils literal"><span class="pre">r</span></span> and <span class="docutils literal"><span class="pre">s</span></span> are instances of <span class="docutils literal"><span class="pre">ℝ</span></span>,
i.e. real numbers, is a theorem.
The theorem <span class="docutils literal"><span class="pre">r</span> <span class="pre">==</span> <span class="pre">s</span></span> is true if there is an instance of this type.
So, constructors of <span class="docutils literal"><span class="pre">==</span></span>
declare theorems which are necessarily true.
Therefore, they are axioms of our theory.
In the code above,
all of the constructors start with “AX” to emphasize that they are axioms.</p>
<p>There is one bit of new syntax here: the forall operator “∀”.
The code is fully equivalent to the following more verbose code:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data _==_ : ℝ -&gt; ℝ -&gt; Set where
  AXrefl== : {r : ℝ} -&gt; r == r
  AXsymm== : {r s : ℝ} -&gt; r == s -&gt; s == r
  AXtrans== : {r s t : ℝ} -&gt; r == s -&gt; s == t -&gt; r == t
  AX+0 : {r : ℝ} -&gt; (r + r0) == r
  AXsymm+ : {r s : ℝ} -&gt; (r + s) == (s + r)
  AX+== : {r s t : ℝ} -&gt; r == s -&gt; (r + t) == (s + t)
</pre></div>
</div>
<p>So, <span class="docutils literal"><span class="pre">∀</span> <span class="pre">{r}</span></span> does two things:
it declares <span class="docutils literal"><span class="pre">r</span></span> to be an optional argument
(as you might have guessed from the curly braces,
which we already discussed in an earlier post),
and it causes the type of <span class="docutils literal"><span class="pre">r</span></span> to be inferred
from the remainder of the function signature.
Agda will complain if it cannot infer the type.</p>
<p>For example, how can Agda know the type in <span class="docutils literal"><span class="pre">∀</span> <span class="pre">{r}</span> <span class="pre">-&gt;</span> <span class="pre">r</span> <span class="pre">==</span> <span class="pre">r</span></span>?
Well, we know that <span class="docutils literal"><span class="pre">_==_</span> <span class="pre">:</span> <span class="pre">ℝ</span> <span class="pre">-&gt;</span> <span class="pre">ℝ</span> <span class="pre">-&gt;</span> <span class="pre">Set</span></span>,
so in the expression <span class="docutils literal"><span class="pre">r</span> <span class="pre">==</span> <span class="pre">r</span></span>, it must be that <span class="docutils literal"><span class="pre">r</span></span> has type <span class="docutils literal"><span class="pre">ℝ</span></span>.</p>
</div>
<div class="section" id="a-first-theorem">
<h2>A First Theorem</h2>
<p>Let us prove a first theorem: <span class="docutils literal"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">+</span> <span class="pre">r</span></span>.
This follows from  <span class="docutils literal"><span class="pre">AXsymm+</span></span> (<span class="docutils literal"><span class="pre">0</span> <span class="pre">+</span> <span class="pre">r</span> <span class="pre">=</span> <span class="pre">r</span> <span class="pre">+</span> <span class="pre">0</span></span>) and <span class="docutils literal"><span class="pre">AX+0</span></span> (<span class="docutils literal"><span class="pre">r</span> <span class="pre">+</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">r</span></span>),
by transitivity (<span class="docutils literal"><span class="pre">AXtrans</span> <span class="pre">==</span></span>), as well as symmetry (<span class="docutils literal"><span class="pre">AXsymm==</span></span>).</p>
<p>In Agda, this can be written as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre>THM0+ : {r : ℝ} -&gt; r == (r0 + r)
THM0+ = AXsymm== (AXtrans== AXsymm+ AX+0)
-- AXsymm+ AX+0   r0 + r == r + r0 and r + r0 == r
-- AXtrans==      so r0 + r == r
-- AXsymm==       so r == r0 + r
</pre></div>
</div>
<p>Agda resolved all hidden parameters for us.
This really simplified the notation.
Here is how the same proof looks like with all parameters specified:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">THM0</span><span class="o">+</span> <span class="p">{</span><span class="n">r</span><span class="p">}</span> <span class="ow">=</span> <span class="kt">AXsymm</span><span class="o">==</span> <span class="p">{</span><span class="n">r0</span> <span class="o">+</span> <span class="n">r</span><span class="p">}</span> <span class="p">{</span><span class="n">r</span><span class="p">}</span> <span class="p">((</span><span class="kt">AXtrans</span><span class="o">==</span> <span class="p">{</span><span class="n">r0</span> <span class="o">+</span> <span class="n">r</span><span class="p">}</span> <span class="p">{</span><span class="n">r</span> <span class="o">+</span> <span class="n">r0</span><span class="p">}</span> <span class="p">{</span><span class="n">r</span><span class="p">})</span> <span class="p">(</span><span class="kt">AXsymm</span><span class="o">+</span> <span class="p">{</span><span class="n">r0</span><span class="p">}</span> <span class="p">{</span><span class="n">r</span><span class="p">})</span> <span class="p">(</span><span class="kt">AX</span><span class="o">+</span><span class="mi">0</span> <span class="p">{</span><span class="n">r</span><span class="p">}))</span>
</pre></div>
</div>
<p>This kind of symplicity really helps readability,
although it probably also hurts understanding the code to some extent.
But it does not really hurt understanding how the proof work:
because we can omit all instances of reals,
all that is left are the axioms (and theorems, later) that have been applied,
and in what order.
This provides a nice summary of the proof.</p>
<p>What is amazing here is that it is <em>not</em> a summary.
<strong>All variables in the proof can be inferred unambiguously from the axioms and the order in which they are applied.</strong>
I am not sure whether this is possible in general (probably not),
but it surely is a nice feature of Agda.</p>
</div>
<div class="section" id="another-theorem">
<h2>Another Theorem</h2>
<p>Here are some axioms for strict inequality:</p>
<div class="highlight-haskell"><div class="highlight"><pre>data _&lt;_ : ℝ -&gt; ℝ -&gt; Set where
  AXtrans&lt;&lt;&lt; : ∀ {r s t} -&gt; r &lt; s -&gt; s &lt; t -&gt; r &lt; t
  AX&lt;=&lt; : ∀ {r s t} -&gt; r &lt; s -&gt; s == t -&gt; r &lt; t
  AX=&lt;&lt; : ∀ {r s t} -&gt; r == s -&gt; s &lt; t -&gt; r &lt; t
  AX0&lt;1 : r0 &lt; r1
  AX+&lt;&lt; : ∀ {r s t} -&gt; r &lt; s -&gt; (r + t) &lt; (s + t)
</pre></div>
</div>
<p>Let us prove that <span class="docutils literal"><span class="pre">r</span> <span class="pre">&lt;</span> <span class="pre">r</span> <span class="pre">+</span> <span class="pre">1</span></span>.</p>
<div class="highlight-haskell"><div class="highlight"><pre>THM&lt;+1 : {r : ℝ} -&gt; r &lt; (r + r1)
THM&lt;+1 = AX&lt;=&lt; (AX=&lt;&lt; THM0+ (AX+&lt;&lt; AX0&lt;1)) AXsymm+
-- AX0&lt;1              0 &lt; 1
-- AX&lt;+ %             so 0 + r &lt; 1 + r
-- AX=&lt;&lt; THM0+ %      so r &lt; 1 + r
-- AX&lt;=&lt; % AXsymm+    so r &lt; r + 1
</pre></div>
</div>
<p>Again, to interpret these proofs, it is useful
to first decipher the ordering in which the axioms and theorems
are applied.
The innermost expression is <span class="docutils literal"><span class="pre">AX0&lt;1</span></span>.
We start from there and work our way to the outer expression
to get to the full proof, as explained in the comments.
I used <span class="docutils literal"><span class="pre">%</span></span> as a symbol for the expression on the previous line
(as in Maple).</p>
<p>Is the sky the limit?
There seems nothing preventing us to do the entire real calculus.
Let us try this in a next post.</p>
</div>
</div>]]></description>
             <pubDate>Wed, 15 Jan 2014 00:00:00 +0000</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/01/13/propositional_logic_in_agda.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/01/13/propositional_logic_in_agda.html</guid>
            <title><![CDATA[Propositional Logic in Agda]]></title>
            <description><![CDATA[<div class="section" id="propositional-logic-in-agda">
<h1>Propositional Logic in Agda</h1>
<div class="section" id="types-are-theorems-proofs-are-instances-implications-are-functions">
<h2>Types are Theorems, Proofs are Instances, Implications are Functions</h2>
<p>In the last post, we looked at Agda,
a extension of Haskell which implements dependent types,
to assist us in proving theorems.
In Agda, theorems are types, and proofs are instances of types.
To verify the proof of a theorem,
we define a function whose type signature corresponds to the theorem,
and whose implementation is an instance of that type, namely, the proof.</p>
<p>Why functions? Because functions embody implication.
Specifically, A implies B
if every proof of A can be transformed into a proof of B.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">_implies_</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
<span class="kt">A</span> <span class="n">implies</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">B</span>
</pre></div>
</div>
<p>So, in Agda, we essentially reason by transforming proofs.
This corresponds nicely to how traditional mathematical reasoning works.
In this post, we will further explore propositional logic
to gain more confidence in proof transformation.</p>
<p>We will not use the above <span class="docutils literal"><span class="pre">implies</span></span> operator any more,
and instead directly write <span class="docutils literal"><span class="pre">-&gt;</span></span> for implication.</p>
</div>
<div class="section" id="conjunction-and-disjunction">
<h2>Conjunction and Disjunction</h2>
<p>How do we model logical ‘and’ and logical ‘or’?
Both operators take two theorems, and return a new theorem,
so the type signatures should be as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">_and_</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
<span class="nf">_or_</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
</pre></div>
</div>
<p>The implementations are also reasonably obvious:
<span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span></span> is proven
if we have an instance of <span class="docutils literal"><span class="pre">A</span></span> and an instance of <span class="docutils literal"><span class="pre">B</span></span>,
for instance, it could return a pair, i.e. a Haskell tuple.
On the other hand, <span class="docutils literal"><span class="pre">A</span> <span class="pre">or</span> <span class="pre">B</span></span> is proven
if we have an instance of <span class="docutils literal"><span class="pre">A</span></span> or an instance of <span class="docutils literal"><span class="pre">B</span></span>:
we could use Haskell’s <span class="docutils literal"><span class="pre">Either</span></span> type.</p>
<p>As far as I know,
Agda has no builtin implementation for tuples,
and it also has no <span class="docutils literal"><span class="pre">Either</span></span> type, but it is easy to roll our own.
For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Pair</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="kr">_</span><span class="p">,</span><span class="kr">_</span> <span class="kt">:</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">B</span> <span class="ow">-&gt;</span> <span class="kt">Pair</span> <span class="kt">A</span> <span class="kt">B</span>

<span class="kr">data</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="n">left</span> <span class="kt">:</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">A</span> <span class="kt">B</span>
  <span class="n">right</span> <span class="kt">:</span> <span class="kt">B</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">A</span> <span class="kt">B</span>

<span class="nf">_and_</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
<span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">Pair</span> <span class="kt">A</span> <span class="kt">B</span>

<span class="nf">_or_</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
<span class="kt">A</span> <span class="n">or</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">Either</span> <span class="kt">A</span> <span class="kt">B</span>
</pre></div>
</div>
<p>The syntax for declaring data types is slightly different from Haskell’s,
so this deserves some explanation.
<span class="docutils literal"><span class="pre">Pair</span></span> has constructor <span class="docutils literal"><span class="pre">_,_</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">Pair</span> <span class="pre">A</span> <span class="pre">B</span></span>.
The return type of a constructor is always the type it is defined for.
What this signature thus says is that <span class="docutils literal"><span class="pre">_,_</span></span> constructs a
new instance of <span class="docutils literal"><span class="pre">Pair</span> <span class="pre">A</span> <span class="pre">B</span></span>
by taking an instance of <span class="docutils literal"><span class="pre">A</span></span> and an instance of <span class="docutils literal"><span class="pre">B</span></span>.
Remember that, in Haskell and also in Agda,
constructors of algebraic data types do not declare their implementation
as in C++, Python, or Java.
In Haskell and Agda, constructors simply define expressions
that create instances of a particular type.</p>
</div>
<div class="section" id="expressing-a-proof-as-a-function">
<h2>Expressing a Proof as a Function</h2>
<p>Let us prove that <span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span></span> implies <span class="docutils literal"><span class="pre">A</span> <span class="pre">or</span> <span class="pre">B</span></span>:
How does this work? Let us first do the proof in words,
and then translate it into Agda code.
Clearly, if <span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span></span> holds, then <span class="docutils literal"><span class="pre">A</span></span> holds.
But if <span class="docutils literal"><span class="pre">A</span></span> holds, then <span class="docutils literal"><span class="pre">A</span> <span class="pre">or</span> <span class="pre">B</span></span> holds.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">lemma</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">A</span>
<span class="nf">lemma</span> <span class="kt">A</span> <span class="kt">B</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>

<span class="nf">theorem</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">or</span> <span class="kt">B</span><span class="p">)</span>
<span class="nf">theorem</span> <span class="kt">A</span> <span class="kt">B</span> <span class="n">ab</span> <span class="ow">=</span> <span class="n">left</span> <span class="p">(</span><span class="n">lemma</span> <span class="kt">A</span> <span class="kt">B</span> <span class="n">ab</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <span class="docutils literal"><span class="pre">lemma</span></span> proves that if <span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span></span> holds, then <span class="docutils literal"><span class="pre">A</span></span> holds.
To do so, we take a proof of <span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span></span>, which is <span class="docutils literal"><span class="pre">(a</span> <span class="pre">,</span> <span class="pre">b)</span></span>,
and transform it into a proof of <span class="docutils literal"><span class="pre">A</span></span>, which is <span class="docutils literal"><span class="pre">a</span></span>.
Next, <span class="docutils literal"><span class="pre">theorem</span></span> proves the initial statement.
We take our proof of <span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span></span>, which we denote by <span class="docutils literal"><span class="pre">ab</span></span>,
then apply <span class="docutils literal"><span class="pre">lemma</span></span> to get a proof of <span class="docutils literal"><span class="pre">A</span></span>,
and then turn this into an instance of <span class="docutils literal"><span class="pre">A</span> <span class="pre">or</span> <span class="pre">B</span></span>.</p>
<p>Something rather interesting is happening in the last step:
constructors can be used as theorems too!
Our type signature
<span class="docutils literal"><span class="pre">left</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">A</span> <span class="pre">B</span></span>
means that, from a proof of <span class="docutils literal"><span class="pre">A</span></span>, we can prove <span class="docutils literal"><span class="pre">Either</span> <span class="pre">A</span> <span class="pre">B</span></span>,
which is the same as <span class="docutils literal"><span class="pre">A</span> <span class="pre">or</span> <span class="pre">B</span></span>.
In a sense, <strong>constructors are the axioms of our theory</strong>.</p>
<p>To make this more formal, we could simply get rid of <span class="docutils literal"><span class="pre">Pair</span></span> and <span class="docutils literal"><span class="pre">Either</span></span>,
and directly write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="n">_and_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="kr">_</span><span class="p">,</span><span class="kr">_</span> <span class="kt">:</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">B</span> <span class="ow">-&gt;</span> <span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span>

<span class="kr">data</span> <span class="n">_or_</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="n">left</span> <span class="kt">:</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">A</span> <span class="n">or</span> <span class="kt">B</span>
  <span class="n">right</span> <span class="kt">:</span> <span class="kt">B</span> <span class="ow">-&gt;</span> <span class="kt">A</span> <span class="n">or</span> <span class="kt">B</span>
</pre></div>
</div>
<p>Agda has some useful syntax
that saves us from having to write all arguments:
any arguments between curly braces can be omitted
if they can be unambiguously inferred.
With this in mind, the proof becomes a little bit more readable:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">lemma</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">A</span>
<span class="nf">lemma</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>

<span class="nf">theorem</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">or</span> <span class="kt">B</span><span class="p">)</span>
<span class="nf">theorem</span> <span class="n">ab</span> <span class="ow">=</span> <span class="n">left</span> <span class="p">(</span><span class="n">lemma</span> <span class="n">ab</span><span class="p">)</span>
</pre></div>
</div>
<p>(So, <span class="docutils literal"><span class="pre">lemma</span></span> is simply Haskell’s <span class="docutils literal"><span class="pre">fst</span></span>!)</p>
<p>Finally, note that we could also have integrated
the lemma into the proof of the theorem:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">theorem</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">or</span> <span class="kt">B</span><span class="p">)</span>
<span class="nf">theorem</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">left</span> <span class="n">a</span>
</pre></div>
</div>
</div>
<div class="section" id="using-pattern-matching-to-prove-distinct-cases">
<h2>Using Pattern Matching to Prove Distinct Cases</h2>
<p>Let us prove another theorem:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">distributivity</span> <span class="kt">:</span> <span class="p">{</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">C</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">}</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="p">(</span><span class="kt">B</span> <span class="n">or</span> <span class="kt">C</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">B</span><span class="p">)</span> <span class="n">or</span> <span class="p">(</span><span class="kt">A</span> <span class="n">and</span> <span class="kt">C</span><span class="p">))</span>
<span class="nf">distributivity</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">left</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">left</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">distributivity</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">right</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="n">right</span> <span class="p">(</span><span class="n">a</span> <span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we exploited pattern matching to prove two cases separately.
An instance of <span class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">(B</span> <span class="pre">or</span> <span class="pre">C)</span></span>
is a proof of <span class="docutils literal"><span class="pre">A</span></span> (<span class="docutils literal"><span class="pre">a</span></span>),
along with a proof of either <span class="docutils literal"><span class="pre">B</span></span> (<span class="docutils literal"><span class="pre">left</span> <span class="pre">b</span></span>) or <span class="docutils literal"><span class="pre">C</span></span> (<span class="docutils literal"><span class="pre">right</span> <span class="pre">c</span></span>).
We can convert <span class="docutils literal"><span class="pre">(a</span> <span class="pre">,</span> <span class="pre">left</span> <span class="pre">b)</span></span>
into an instance of <span class="docutils literal"><span class="pre">((A</span> <span class="pre">and</span> <span class="pre">B)</span> <span class="pre">or</span> <span class="pre">(A</span> <span class="pre">and</span> <span class="pre">C))</span></span>, namely <span class="docutils literal"><span class="pre">left</span> <span class="pre">(a</span> <span class="pre">,</span> <span class="pre">b)</span></span>.
Similarly, we can convert <span class="docutils literal"><span class="pre">(a</span> <span class="pre">,</span> <span class="pre">left</span> <span class="pre">b)</span></span>
into an instance of <span class="docutils literal"><span class="pre">((A</span> <span class="pre">and</span> <span class="pre">B)</span> <span class="pre">or</span> <span class="pre">(A</span> <span class="pre">and</span> <span class="pre">C))</span></span>, namely <span class="docutils literal"><span class="pre">right</span> <span class="pre">(a</span> <span class="pre">,</span> <span class="pre">c)</span></span>.</p>
</div>
</div>]]></description>
             <pubDate>Mon, 13 Jan 2014 00:00:00 +0000</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/01/09/agda__dependent_types__theorem_proving.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2014/01/09/agda__dependent_types__theorem_proving.html</guid>
            <title><![CDATA[Agda, Dependent Types, Theorem Proving]]></title>
            <description><![CDATA[<div class="section" id="agda-dependent-types-theorem-proving">
<h1>Agda, Dependent Types, Theorem Proving</h1>
<div class="section" id="agda">
<h2>Agda</h2>
<p>A few days ago, I stumbled on
<a class="reference external" href="http://youtu.be/vy5C-mlUQ1w">David Sankel’s talk at BoostCon 2013</a>
on Agda.
Whilst the focus of the talk is, eventually, software design,
computer assisted theorem proving was repeatedly mentioned.
Some years ago I tried
the proof assistent
<a class="reference external" href="http://www.cl.cam.ac.uk/research/hvg/Isabelle">Isabelle</a>
but I never really played around enough in it to a point
where I could really use it.</p>
<p>Now, what David Sankel’s talk made me realise,
is that functional programming languages are a stepping stone to
proof assistents.
The only bit missing from Haskell to make this happen
are so-called <em>dependent types</em>.
Take Haskell, add dependent types, and you get Agda!
So, for the next few months,
I have set myself the task of understanding how exactly this works.</p>
</div>
<div class="section" id="types-as-instances">
<h2>Types as Instances</h2>
<p>The first important feature which enables assisted theorem proving
in Agda is the unification of types and instances.
In many languages,
including C++ and Haskell,
types and instances are completely different concepts.
In Agda, types are instances as well.
This is certainly not unique to Agda.
For example, in Python, types are called classes,
and it turns out that an instance of a class can be another class:
simply derive your class from <span class="docutils literal"><span class="pre">type</span></span>.
Such class is called a <em>metaclass</em> in Python,
to distinguish it from <cite>standard’ classes, which derive from ``object`</cite>.
In Agda, by convention,
standard types are instances of a builtin type called <span class="docutils literal"><span class="pre">Set</span></span>.
So, one could think of Agda’s <span class="docutils literal"><span class="pre">Set</span></span> as Python’s <span class="docutils literal"><span class="pre">type</span></span>.</p>
<p>There is however one crucial difference:
in Agda, <span class="docutils literal"><span class="pre">Set</span></span> is not an instance of <span class="docutils literal"><span class="pre">Set</span></span>,
whereas <span class="docutils literal"><span class="pre">type</span></span> is an instance of <span class="docutils literal"><span class="pre">type</span></span> in Python:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="kt">:</span> <span class="kt">Set</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="kt">Set</span>
</pre></div>
</div>
<p>will fail to load in Agda, but</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>runs just fine in Python.
Instead, in Agda, <span class="docutils literal"><span class="pre">Set</span></span> is an instance of <span class="docutils literal"><span class="pre">Set1</span></span>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="kt">:</span> <span class="kt">Set1</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="kt">Set</span>
</pre></div>
</div>
<p>loads just fine in Agda.
There are deep reasons for <span class="docutils literal"><span class="pre">Set</span></span> not being an instance of itself:
if <span class="docutils literal"><span class="pre">Set</span></span> were an instance of <span class="docutils literal"><span class="pre">Set</span></span>, then
<a class="reference external" href="https://en.wikipedia.org/wiki/Russell%27s_paradox">Russell’s paradox</a>
would hold true.
Coming from a standard set-theoretic background,
it can be helpful to think of types as sets,
and of the colon operator <span class="docutils literal"><span class="pre">:</span></span>
as an <cite>is an element of’ operator `</cite> ∈``.</p>
</div>
<div class="section" id="dependent-types">
<h2>Dependent Types</h2>
<p>What are they?
Informally, they are types which depend on a value,
like templates in C++. Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">id</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">A</span>
<span class="nf">id</span> <span class="kr">_</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span>
</pre></div>
</div>
<p>The type signature declares a function, which takes
as arguments an arbitrary type and a value of that type,
and returns a value of that type.
The definition is simply the identity map.
Something to blow your mind:
could you define any other function with the same function signature?</p>
<p>In the above example,
the second argument and the return value have dependent types,
because their type depends on the first argument.</p>
</div>
<div class="section" id="proving-theorems">
<h2>Proving Theorems</h2>
<p>With just these ingredients—static typing with unified types and instances,
and dependent types—we can do all of constructive mathematics.
How does this work? The key thing to remember is that
<strong>a theorem is a type</strong>,
and <strong>a proof of that theorem is an instance of that type.</strong>
That sounds weird at first, so let us first explore some simple examples.</p>
<p>Let us start with propositional logic.
Propositional logic deals with statements.
In set theory, statements
are usually identified with subsets of some possibility space.
We have seen that we can think of sets as types:
by convention, let us take statements to be instances of Agda’s <span class="docutils literal"><span class="pre">Set</span></span> type.</p>
<p>How do we specify that a statement is true, or false?
Well, theorems are statements, and theorems are true
if they can be proven, that is, if the corresponding type has an instance.
So, we specify that a statement is true simply by stating that it has a value.
For example, we can declare the following algebraic data types: <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">False</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>

<span class="kr">data</span> <span class="kt">True</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="kr">where</span>
  <span class="n">tt</span> <span class="kt">:</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Here, <span class="docutils literal"><span class="pre">False</span></span> is a proposition which has no instances,
or, no proofs. We can identify it with the impossible event.</p>
<p>Conversely, <span class="docutils literal"><span class="pre">True</span></span> is a proposition which is always true,
i.e. we can identify it with the true event:
it has exactly one instance, or proof, namely <span class="docutils literal"><span class="pre">tt</span></span>
(we could declare more constructors, this would make no practical difference).</p>
<p>So, what can we do with propositions?
Well, one proposition can imply another.
How do we formalize that?
We need to distinguish carefully between two things:
the statement that A implies B,
which is a theorem and hence an instance of <span class="docutils literal"><span class="pre">Set</span></span>,
and an actual proof of A implying B,
which is an instance of the theorem’s type.</p>
<p>How do we produce a new statement from two existing statements?
We use a function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">_implies_</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="ow">-&gt;</span> <span class="kt">Set</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
</pre></div>
</div>
<p>(The underscores make this an infix function, which will read better.)
So, the function <span class="docutils literal"><span class="pre">implies</span></span> takes as arguments two statements or theorems,
and uses them to produce a new statement. What statement?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">A</span> <span class="n">implies</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">A</span> <span class="ow">-&gt;</span> <span class="kt">B</span>
</pre></div>
</div>
<p>The set of functions from A to B? What does this mean?
It means that <span class="docutils literal"><span class="pre">A</span> <span class="pre">implies</span> <span class="pre">B</span></span> is considered true
if there is an instance of <span class="docutils literal"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></span>,
that is if
<strong>there is a function that transforms any proof of A into a proof of B</strong>.</p>
<p>We can now prove a first theorem:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">thmimpliesisreflexive</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">A</span> <span class="n">implies</span> <span class="kt">A</span><span class="p">)</span>
<span class="nf">thmimpliesisreflexive</span> <span class="kt">A</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>The definition of the proof reads as follows.
The function has one argument:
<span class="docutils literal"><span class="pre">A</span></span> is simply the theorem or statement under consideration.
The result is an implication, which we represent as a function.
For our purpose, the identity map <span class="docutils literal"><span class="pre">\a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></span> does the job.
<span class="docutils literal"><span class="pre">a</span></span> is a proof of the left hand side of the implication,
namely of <span class="docutils literal"><span class="pre">A</span></span>.
The function needs to produce
a proof for the right hand side of the implication, which is also <span class="docutils literal"><span class="pre">A</span></span>.
Obviously, we can simply return the same proof <span class="docutils literal"><span class="pre">a</span></span> again.</p>
<p>A more tricky case:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">thmfimpt</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">False</span> <span class="n">implies</span> <span class="kt">True</span><span class="p">)</span>
<span class="nf">thmfimpt</span> <span class="nb">()</span>
</pre></div>
</div>
<p>The type <span class="docutils literal"><span class="pre">False</span> <span class="pre">implies</span> <span class="pre">True</span></span> simply maps proofs of <span class="docutils literal"><span class="pre">False</span></span>
to proofs of <span class="docutils literal"><span class="pre">True</span></span>.
But, there are no proofs of <span class="docutils literal"><span class="pre">False</span></span>.
Consequently, <span class="docutils literal"><span class="pre">thmfimpt</span></span> is simply the empty function,
mapping nothing to nothing.
In Agda, we say that a function is empty by writing empty brackets.</p>
<p>Can we do negation? Easily, in terms of implication:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">not</span> <span class="kt">:</span> <span class="kt">Set</span> <span class="ow">-&gt;</span> <span class="kt">Set</span>
<span class="nf">not</span> <span class="kt">A</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">A</span> <span class="n">implies</span> <span class="kt">False</span><span class="p">)</span>
</pre></div>
</div>
<p>So, <span class="docutils literal"><span class="pre">not</span> <span class="pre">A</span></span> is true if we can map every proof of <span class="docutils literal"><span class="pre">A</span></span>
to a proof of <span class="docutils literal"><span class="pre">False</span></span>.
But, <span class="docutils literal"><span class="pre">False</span></span> has no proofs. So we can only do this if <span class="docutils literal"><span class="pre">A</span></span> has no proofs.
Similarly, <span class="docutils literal"><span class="pre">not</span> <span class="pre">A</span></span> is false
if there is no map from a proof of <span class="docutils literal"><span class="pre">A</span></span> to a proof of <span class="docutils literal"><span class="pre">False</span></span>.
This happens as soon as <span class="docutils literal"><span class="pre">A</span></span> has a proof
(otherwise, if there would be such a map, <span class="docutils literal"><span class="pre">False</span></span> would be true).</p>
<p>So, to show that <span class="docutils literal"><span class="pre">not</span> <span class="pre">A</span></span> is true,
effectively, we must establish that there is no proof of <span class="docutils literal"><span class="pre">A</span></span>.
To do this, we rely on contradiction: assuming we had a proof
for <span class="docutils literal"><span class="pre">A</span></span>, we find a map that gives us a proof for <span class="docutils literal"><span class="pre">False</span></span>.
Agda’s typechecker will figure out from this that <span class="docutils literal"><span class="pre">A</span></span> has no proofs:
if it had, it would have a proof of <span class="docutils literal"><span class="pre">False</span></span>,
which would contradict the type declaration of <span class="docutils literal"><span class="pre">False</span></span>.</p>
<p>Here is an example of proving a negation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">thmntimpf</span> <span class="kt">:</span> <span class="n">not</span> <span class="p">(</span><span class="kt">True</span> <span class="n">implies</span> <span class="kt">False</span><span class="p">)</span>
<span class="nf">thmntimpf</span> <span class="n">timpf</span> <span class="ow">=</span> <span class="n">timpf</span> <span class="n">tt</span>
</pre></div>
</div>
<p>How do we interpret this proof?
The function signature reduces to <span class="docutils literal"><span class="pre">True</span> <span class="pre">implies</span> <span class="pre">False</span> <span class="pre">-&gt;</span> <span class="pre">False</span></span>,
so <span class="docutils literal"><span class="pre">timpf</span></span> is a proof of <span class="docutils literal"><span class="pre">True</span> <span class="pre">implies</span> <span class="pre">False</span></span>.
Applying this function to our proof of truth, <span class="docutils literal"><span class="pre">tt</span></span>,
we get a proof of <span class="docutils literal"><span class="pre">False</span></span>,
establishing the contradiction.</p>
<p>Let us finish with proving something slightly less trivial:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">thmcontraposition</span> <span class="kt">:</span> <span class="p">(</span><span class="kt">A</span> <span class="kt">B</span> <span class="kt">:</span> <span class="kt">Set</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">((</span><span class="kt">A</span> <span class="n">implies</span> <span class="kt">B</span><span class="p">)</span> <span class="n">implies</span> <span class="p">((</span><span class="n">not</span> <span class="kt">B</span><span class="p">)</span> <span class="n">implies</span> <span class="p">(</span><span class="n">not</span> <span class="kt">A</span><span class="p">)))</span>
<span class="nf">thmcontraposition</span> <span class="kt">A</span> <span class="kt">B</span> <span class="n">aimpb</span> <span class="n">nb</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">nb</span> <span class="p">(</span><span class="n">aimpb</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>How do we arrive at this proof? In emacs, write the proof definition as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">thmcontraposition</span> <span class="kt">A</span> <span class="kt">B</span> <span class="ow">=</span> <span class="p">{</span><span class="o">!</span> <span class="o">!</span><span class="p">}</span>
</pre></div>
</div>
<p>and use C-c C-l to load the file. This will tell you that
the normalised type signature of the expression between curly brackets is
<span class="docutils literal"><span class="pre">A</span> <span class="pre">implies</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">not</span> <span class="pre">B</span> <span class="pre">-&gt;</span> <span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">False</span></span>
(this is also easy to figure this out without the help of Agda,
but using Agda to provide hints like this saves some time).
In other words,
<span class="docutils literal"><span class="pre">aimpb</span></span> proves <span class="docutils literal"><span class="pre">A</span> <span class="pre">implies</span> <span class="pre">B</span></span>,
<span class="docutils literal"><span class="pre">nb</span></span> proves <span class="docutils literal"><span class="pre">not</span> <span class="pre">B</span></span>,
and <span class="docutils literal"><span class="pre">a</span></span> proves <span class="docutils literal"><span class="pre">A</span></span>.
We must produce <span class="docutils literal"><span class="pre">False</span></span>: a contradiction.
Indeed,
<span class="docutils literal"><span class="pre">aimpb</span> <span class="pre">a</span></span> turns <span class="docutils literal"><span class="pre">a</span></span> into a proof of <span class="docutils literal"><span class="pre">B</span></span>.
And <span class="docutils literal"><span class="pre">nb</span></span> turns this proof into a proof of <span class="docutils literal"><span class="pre">False</span></span>. Done!</p>
<p>Note that <span class="docutils literal"><span class="pre">nb</span> <span class="pre">(aimpb</span> <span class="pre">a)</span></span> translates directly into
the proof by contradiction:
Given A implies B, and not B,
we must show that A does not hold.
Assume, A were to hold (<span class="docutils literal"><span class="pre">a</span></span>).
Then, because A implies B, B needs to hold as well (<span class="docutils literal"><span class="pre">aimpb</span> <span class="pre">a</span></span>).
But, B does not hold, so we arrived at a contradiction (<span class="docutils literal"><span class="pre">nb</span> <span class="pre">(aimpb</span> <span class="pre">a)</span></span>).</p>
<p>Finally,
note that the actual act of theorem proving
does not involve compilation
of the code into a binary.
The theorems are proved as soon as it is verified
that the function definitions match the type signatures.
So, <strong>theorem proving is just a special case of type checking</strong>.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">In Haskell, this would be:</p>
<div class="last highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">False</span>
<span class="kr">data</span> <span class="kt">True</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
</td></tr>
</tbody>
</table>
</div>
</div>]]></description>
             <pubDate>Thu, 09 Jan 2014 00:00:00 +0000</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/09/10/typeclasses.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/09/10/typeclasses.html</guid>
            <title><![CDATA[Typeclasses]]></title>
            <description><![CDATA[<div class="section" id="typeclasses">
<h1>Typeclasses</h1>
<div class="section" id="polymorphism">
<h2>Polymorphism</h2>
<p>We already saw one way to achieve polymorphism in Haskell:
<a class="reference internal" href="http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/21/everything_is_a_function.html#type-variables"><em>type variables</em></a>. For example,
we defined function composition as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">$</span> <span class="n">g</span> <span class="n">x</span>
</pre></div>
</div>
<p>Above, <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span> are generic placeholders
to denote arbitrary types. These are called type variables.</p>
<p>If we think about generalising the monad pattern to general types,
we will quickly find that type variables cannot help us doing so.
Why is that? Well, to use the monad pattern, we need, in essence,
to define a function that binds our monadic structures.
Looking at further examples,
we will very quickly find that we cannot implement this binding operation
in a fully generic way using type variables, because the implementation
of the binding operation is highly tied to the monad structure itself.
In terms of, say, C++, we would like to overload the binding function
for different types.</p>
<p>This is exactly what a <em>typeclass</em> does: it allows us to specify that
a certain type implements certain functions.
The monad typeclass is defined as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Note that we are also required to implement a return function
to embed a type into our monad;
actually, for may examples, this is not really required,
but it can be useful in case a type’s constructors are hidden.
Note that the bind operator <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> and the <span class="docutils literal"><span class="pre">return</span></span> function
are required to be polymorphic, through type variables.</p>
<p>So, in essence,
typeclasses are used to declare that
a particular type implements a particular interface.
For example, the list monad would be implemented as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="n">xs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">$</span> <span class="n">xs</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>Of course, we do not have to type the above ourselves;
Haskell has already done that for us.</p>
</div>
<div class="section" id="a-simple-container-monad">
<h2>A Simple Container Monad</h2>
<p>Let us proceed to a second example of a monad.
Suppose we are carrying out a computation on some value,
but each step of the computation might fail for some reason.
In case of failure, we simply wish to return a dummy value
to signal this failure.</p>
<p>For the time being, let us use a list for this purpose:
an empty list denotes a failed computation, and a non-empty list
of length one denotes successful computation,
with the value it stores being the value computed so far.</p>
<p>As an example of computation, we will parse three digits into an
integer.
A first challenge is to convert a single character into a numerical value.
For this we use the <span class="docutils literal"><span class="pre">ord</span></span> function from the <span class="docutils literal"><span class="pre">Data.Char</span></span> module:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Char</span>
</pre></div>
</div>
<p>We will construct our parser by chaining. A single step of the algorithm
consists of taking a character from the front of a string
(we could also take it from the back, but Haskell encourages
it the other way around), trying to convert it to an integer,
and returning that integer along with the remainder of the characters
still to convert. So, ideally, we would like our function signature to be:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
</pre></div>
</div>
<p>Two problems still to solve are:
(i) how to deal with error conditions, and
(ii) how to allow this function to be recursively “eat” characters.
We change the function signature somewhat to accommodate both issues:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])]</span>
</pre></div>
</div>
<p>Two things have happened: we have written the function
to take just a single argument, namely, a tuple of <span class="docutils literal"><span class="pre">Int</span></span> and <span class="docutils literal"><span class="pre">[Char]</span></span>.
This will simplify chaining: suppose we have eaten a character
and are left with a remaining string, then we can simply call
the function again to get the next digit with its remaining string, and so on.
The second change is that the function now returns a list,
so an empty list can signal an error condition,
and a single element list can signal successful parsing.</p>
<p>Here is the full implementation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])]</span>
<span class="nf">getdigit</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">getdigit</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="ow">=</span> <span class="p">[(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">xs</span><span class="p">)]</span>
  <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="kt">[]</span>
  <span class="kr">where</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>
</pre></div>
</div>
<p>In case of invalid input (empty string, or non-numerical character),
the function simply returns an empty string.
If the input is valid, then the function multiplies the result so far by 10,
and adds the parsed digit to that result;
it also returns the remaining characters.</p>
<p>How can we now parse, say, a three-digit integer?
The list monad helps us out:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getint</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])]</span>
<span class="nf">getint</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">getdigit</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit</span>
</pre></div>
</div>
<p>That looks rather elegant, but what is going on here?</p>
<p>Remember what the list monad does: it takes a list, applies a function
to all elements of that list, and then concatenates the resulting
elements of that list. Let us analyse this process in the above code.
First, we start with <span class="docutils literal"><span class="pre">getdigit</span> <span class="pre">(0,</span> <span class="pre">xs)</span></span>.
If, on the one hand,
the input <span class="docutils literal"><span class="pre">xs</span></span> is empty, or has an invalid first character,
then we end up with an empty list.
If, on the other hand,
the input <span class="docutils literal"><span class="pre">xs</span></span> starts with a valid character,
then we get a list containing the value of that character,
along with the tail of <span class="docutils literal"><span class="pre">xs</span></span>, i.e. all characters still to process.</p>
<p>The monad operation <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> will then apply <span class="docutils literal"><span class="pre">getdigit</span></span>
to all elements of the list we just obtained—remember that this
list is either empty, or contains exactly one element.
If that list was empty, <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> will just return an empty list again
without even calling <span class="docutils literal"><span class="pre">getdigit</span></span>.
If that list contained one element,
it will multiply the original result by 10, add the newly processed digit
to the result, and return a list containing one pair,
namely the result and the remaining characters.
If at this stage, parsing fails, an empty list is produced.</p>
<p>Rinse and repeat.</p>
</div>
<div class="section" id="maybe">
<h2>Maybe</h2>
<p>Using a list to keep track of a failure mode is somewhat contorted:
we are using a cannon to shoot a fly.
Haskell provides a simpler data structure just for the purpose
of storing so-called <em>optional</em> values:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<p>Semantically, a <span class="docutils literal"><span class="pre">Maybe</span></span> is just like a list with at most one element.
Its monad implementation is somewhat simpler than that of lists:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
</pre></div>
</div>
<p>The full implementation becomes:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">getdigit2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">getdigit2</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">getdigit2</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="kt">Nothing</span>
  <span class="kr">where</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>

<span class="nf">getint2</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">getint2</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">getdigit2</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit2</span> <span class="o">&gt;&gt;=</span> <span class="n">getdigit2</span>
</pre></div>
</div>
<p>This is obviously very similar to our list implementation.
The main difference is that the intent of the code has become clearer
due to the explicit use of <span class="docutils literal"><span class="pre">Maybe</span></span>, <span class="docutils literal"><span class="pre">Nothing</span></span>, and <span class="docutils literal"><span class="pre">Just</span></span>.</p>
</div>
</div>]]></description>
             <pubDate>Tue, 10 Sep 2013 00:00:00 +0100</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/24/the_list_monad.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/24/the_list_monad.html</guid>
            <title><![CDATA[The List Monad]]></title>
            <description><![CDATA[<div class="section" id="the-list-monad">
<h1>The List Monad</h1>
<p>In the last post, we briefly looked at functions.
Today, we will use our learnings
to investigate a first simple example of monads,
namely, lists.</p>
<p>Lists are as fundamental to Haskell as functions.
Indeed, because everything is a function in Haskell,
you may have wondered how one writes loops in such language.
In a purely functional language,
loops are naturally translated to operations on lists.</p>
<div class="section" id="list-syntax">
<h2>List Syntax</h2>
<p>First, some syntax. The empty list is denoted as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">[]</span>
</pre></div>
</div>
<p>Lists can, obviously, contain as many elements as we want.
In fact, in Haskell, a list can even take any countable number of elements.
This is possible because Haskell is lazy.
To compare with Python, lists are like Python generators,
which can also go on to countable infinity.
Finite lists are denoted as follows:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
</pre></div>
</div>
<p>In Haskell, a list consisting of characters is a <em>string</em>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="n">'h'</span><span class="p">,</span><span class="n">'e'</span><span class="p">,</span><span class="n">'l'</span><span class="p">,</span><span class="n">'l'</span><span class="p">,</span><span class="n">'o'</span><span class="p">]</span>
</pre></div>
</div>
<p>Because this notation is rather heavy,
we can write the above list also as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="s">&quot;hello&quot;</span>
</pre></div>
</div>
<p>which is simply syntactic sugar.</p>
<p>The arithmetic progression, say, starting at 5, with step size 2, and
ending at 21, is denoted as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="o">..</span><span class="mi">21</span><span class="p">]</span>
</pre></div>
</div>
<p>We can also denote infinite arithmetic progressions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="o">..</span><span class="p">]</span>
</pre></div>
</div>
<p>In many (or perhaps most?) languages, the fundamental operation to
extend lists is appending, that is, extending at the end of the
list—for example, in Python, it is very natural to use the <span class="docutils literal"><span class="pre">+=</span></span>
operator.
In Haskell however, <em>prepending</em> is the fundamental operation to
extend lists. The reason for this is straightforward: if you allow infinite
lists, prepending is the only sensible extension operator.
The <span class="docutils literal"><span class="pre">:</span></span> (colon) operator denotes prepend:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>How do we denote lists in type signatures? Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">func</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">func</span> <span class="n">xs</span> <span class="ow">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">sum</span> <span class="n">xs</span>
</pre></div>
</div>
<p>So, <span class="docutils literal"><span class="pre">[Int]</span></span> denote a list of <span class="docutils literal"><span class="pre">Int</span></span> elements.
Observe that the argument of <span class="docutils literal"><span class="pre">func</span></span> is called <span class="docutils literal"><span class="pre">xs</span></span>, rather than <span class="docutils literal"><span class="pre">x</span></span>.
It is a useful convention in Haskell code to denote list variables by
<span class="docutils literal"><span class="pre">xs</span></span>, <span class="docutils literal"><span class="pre">ys</span></span>, and so on,
and to denote their elements by <span class="docutils literal"><span class="pre">x</span></span>, <span class="docutils literal"><span class="pre">y</span></span>, and so on.</p>
<p>In Haskell, all of a list’s elements must be of the same type.
For example, we <strong>cannot</strong> write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">'a'</span><span class="p">,</span><span class="s">&quot;xyz&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="comprehension">
<h2>Comprehension</h2>
<p>There is one more notation for lists which is enormously useful:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span>
              <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">15</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="n">n</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="n">n</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>This will give you all numbers, less than 15,
satisfying the conditions of Fermat’s equation <img alt="x^n+y^n=z^n" class="math" src="http://mcmtroffaes.github.io/blowyourmindwithhaskell/_images/math/230acb45f71b4261904fb34a56e5cac92a6e5a40.png"/>;
for the curious, the answer is:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">13</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">15</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note that <img alt="n" class="math" src="http://mcmtroffaes.github.io/blowyourmindwithhaskell/_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png"/> is never larger than 2,
per <a class="reference external" href="http://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem">Fermat’s famous last theorem</a>.
Here is how you could ask Haskell to try to prove the theorem:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="p">[</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span>
                   <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="n">n</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="n">n</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>The calculation is still running on my machine—in fact, it will never end,
because Haskell will simply use brute force,
which is of course problematic
when there are infinitely many cases to consider.
In the above, the function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>returns <span class="docutils literal"><span class="pre">True</span></span> if its list argument is empty—remember
that <span class="docutils literal"><span class="pre">a</span></span> is a type variable,
so this function is polymorphic and will work for lists of any type.</p>
<p>Anyway, let us stop this brief digression and get back to topic: monads!</p>
</div>
<div class="section" id="a-poor-man-s-monad">
<h2>A Poor Man’s Monad</h2>
<p>One way to explain monads, is to try to implement
list comprehension by ourselves, using just functions,
aiming to get as close as possible to the list comprehension syntax.
For this purpose, let us investigate a very simple example,
and try to rewrite:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>which results in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">,</span><span class="mi">30</span><span class="p">]</span>
</pre></div>
</div>
<p>First, let us tackle each of the parts separately,
namely <span class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">[1,2,3]</span></span>, <span class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">[-x,x]</span></span>, and <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">3</span></span>.
Can we rewrite these as functions?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcx</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcx</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="nf">funcy</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcy</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>

<span class="nf">funcfinal</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcfinal</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that we do not actually need <span class="docutils literal"><span class="pre">funcx</span></span>—we introduce it here
merely for the sake of symmetry. The important observation is
that all these functions produce lists.
If we may get slightly ahead of ourselves,
in light of general monad theory,
what matters here is that all these functions
produce <em>containers</em> of the same <em>form</em>.</p>
<p>Next, we need a function to combine <span class="docutils literal"><span class="pre">funcx</span></span>, <span class="docutils literal"><span class="pre">funcy</span></span>, and <span class="docutils literal"><span class="pre">funcfinal</span></span>.
Specifically, we wish to <em>bind</em> the outcome of <span class="docutils literal"><span class="pre">funcx</span></span>
to the input of the function <span class="docutils literal"><span class="pre">funcy</span></span>, and then to <em>bind</em>
the outcome of both of these to <span class="docutils literal"><span class="pre">funcfinal</span></span>.
Here is what you might write in a possible attempt:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">bind</span> <span class="n">zs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">$</span> <span class="n">zs</span>
</pre></div>
</div>
<p>In the above, <span class="docutils literal"><span class="pre">map</span></span> applies a function to every element of a list:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">map</span> <span class="n">funcy</span> <span class="o">$</span> <span class="n">funcx</span>
</pre></div>
</div>
<p>gives:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>The function <span class="docutils literal"><span class="pre">concat</span></span> concatenates this list of lists. Consequently:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">funcx</span> <span class="n">funcy</span>
</pre></div>
</div>
<p>gives:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>This is not exactly the result we want,
but we are clearly getting close:
we already have a list with six elements.
The elements are <span class="docutils literal"><span class="pre">y</span></span> rather than <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">3</span></span>,
because we have not yet used <span class="docutils literal"><span class="pre">funcfinal</span></span>.
Can we use <span class="docutils literal"><span class="pre">bind</span></span> to combine <span class="docutils literal"><span class="pre">funcy</span></span> and <span class="docutils literal"><span class="pre">funcfinal</span></span>?
Of course! For instance:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="p">(</span><span class="n">funcy</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">funcfinal</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>will give us:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>which is the desired result, for <span class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></span>.
The only remaining problem is to feed all values for <span class="docutils literal"><span class="pre">x</span></span>
into this expression:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind2</span> <span class="n">f1</span> <span class="n">f2</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">bind</span> <span class="p">(</span><span class="n">f1</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">f2</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>(The type signature is rather complex, so we have omitted it here.)
To get the final result, we thus apply <span class="docutils literal"><span class="pre">bind</span></span> twice:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">funcx</span> <span class="o">$</span> <span class="n">bind2</span> <span class="n">funcy</span> <span class="n">funcfinal</span>
</pre></div>
</div>
<p>This is about as close as we can get to the original expression:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>where
<span class="docutils literal"><span class="pre">funcx</span></span> represents <span class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">[1,2,3]</span></span>,
<span class="docutils literal"><span class="pre">funcy</span></span> represents <span class="docutils literal"><span class="pre">y</span> <span class="pre">&lt;-</span> <span class="pre">[x,-x]</span></span>, and
<span class="docutils literal"><span class="pre">funcfinal</span></span> represents <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">3</span></span>.
The <span class="docutils literal"><span class="pre">bind</span></span> and <span class="docutils literal"><span class="pre">bind2</span></span> functions are merely glue.</p>
<p>If you followed this far, congratulations!!
You may not realize it yet, but you now know in essence what a monad is.
A monad is a container, along with a higher order function
which binds functions that operate on these containers.
Everything else about monads in Haskell comes down to:</p>
<ol class="arabic simple">
<li>adding syntactic sugar to remove the boilerplate in the above code, and</li>
<li>generalizing from <span class="docutils literal"><span class="pre">[Int]</span></span> lists to arbitrary containers.</li>
</ol>
<p>Yippikayee!</p>
</div>
<div class="section" id="syntactic-sugar">
<h2>Syntactic Sugar</h2>
<p>The aim of this section is
to simplify the structure of our monad code, step by step.</p>
<div class="section" id="infix-notation">
<h3>Infix Notation</h3>
<p>The first thing we can do is rewrite the glue in infix notation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcx</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="n">funcy</span> <span class="p">`</span><span class="n">bind2</span><span class="p">`</span> <span class="n">funcfinal</span><span class="p">)</span>
</pre></div>
</div>
<p>For any function <span class="docutils literal"><span class="pre">f</span></span> in Haskell:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="p">`</span><span class="n">f</span><span class="p">`</span> <span class="n">y</span>
</pre></div>
</div>
<p>is just a shorthand notation for:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="n">x</span> <span class="n">y</span>
</pre></div>
</div>
<p>Backticked functions are left-associative.
In the above, we are using the operators in a right-associative way,
thus we need brackets to denote the order of operation.</p>
</div>
<div class="section" id="lambda-functions">
<h3>Lambda Functions</h3>
<p>To get one more step closer to list comprehension notation,
we would like to get rid of the helper functions.
For this purpose, we can use so-called lambda functions,
which allow us to define anonymous functions directly into our expressions.
Note that the use of lambda functions is somewhat frowned upon,
and are generally only used for very simple functions:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">((</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">])</span> <span class="p">`</span><span class="n">bind2</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>In fact, with lambda functions, we can also get rid of <span class="docutils literal"><span class="pre">bind2</span></span>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])))</span>
</pre></div>
</div>
<p>Oh dear, what has happened here?
Let us look at the unsugared version of this code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">funcx</span> <span class="n">funcxy</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcxy</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">bind</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>or equivalently:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcxy'</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">bind</span> <span class="p">(</span><span class="n">funcy</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">funcfinal</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>It now becomes clear that this is entirely equivalent to the original code,
simply by observing that we could also have written:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">funcxy''</span> <span class="ow">=</span> <span class="n">bind2</span> <span class="n">funcy</span> <span class="n">funcfinal</span>
</pre></div>
</div>
<p>Note that our full code is now down to two lines: a definition of <cite>bind</cite>,
(which is highly generic: we can reuse it for any list comprehension),
and the comprehension itself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="n">zs</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">$</span> <span class="n">zs</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])))</span>
</pre></div>
</div>
<p>We can omit the brackets around lambda definitions, because
the body of the lambda extends as far to the right as possible without hitting
an unbalanced parenthesis <a class="footnote-reference" href="#id2" id="id1">[1]</a>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">`</span><span class="n">bind</span><span class="p">`</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>We got rid of all brackets,
and this <em>almost</em> looks like our list comprehension.</p>
</div>
<div class="section" id="the-operator">
<h3>The <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> Operator</h3>
<p>Because the <span class="docutils literal"><span class="pre">bind</span></span> operation is so generically useful
for arbitrary list comprehensions,
Haskell implements an <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> operator for us,
which behaves just like our <span class="docutils literal"><span class="pre">bind</span></span>.
We get:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>We note that, in this example,
the infix notation, along with the lambda notation,
is absolutely indispensible to make for readable code.
To convince yourself, compare with the prefix notation:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">bind</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">])))</span>
</pre></div>
</div>
<p>or with fewer brackets:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bind</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>which, although perhaps more explicit, may feel less natural.</p>
</div>
<div class="section" id="do-notation-and-the-operator">
<h3>Do Notation and the <span class="docutils literal"><span class="pre">&lt;-</span></span> Operator</h3>
<p>For large list comprehensions, keeping everything on a single line
becomes tedious. Instead, we can write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>where it is <strong>very important to remember that
the body of ``-&gt;`` extends to the right as far as logically possible</strong>,
i.e. with brackets, our code is equivalent to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
    <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
        <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
<p>Perhaps, you will find that this is already obscure enough.
Nevertheless, Haskell allows you to take this yet one step further,
with a so-called do block.
A do block allows us to replace <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> operators with
newlines and some sort of ‘reverse lambda notation’:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
   <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>The only remaining touch we can give this code is to use Haskell’s
<span class="docutils literal"><span class="pre">return</span></span> function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
   <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">return</span></span> function transforms a value into a container
(or, a monad, if you like), and for lists, it is defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>This now looks suspiciously similar to code from an imperative language,
for instance the following in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">3</span>
</pre></div>
</div>
<p>It is tempting, yet flawed,
to think of do blocks as a sequence of imperative statements.
Indeed, Haskell may evaluate expressions in any order it wants,
and is only constrained by data flow. For example, in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
   <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
   <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
</pre></div>
</div>
<p>there is no guarantee whatsoever that Haskell will evaluate <span class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span></span>
before <span class="docutils literal"><span class="pre">[9,10]</span></span>. For all we know,
Haskell might even evaluate them in parallel.</p>
</div>
</div>
<div class="section" id="the-monad-typeclass">
<h2>The Monad Typeclass</h2>
<p>The do notation does not only exist for lists, but applies to any monad.
It is crucial to realize that
<strong>the ``&gt;&gt;=`` operator determines how a do block is evaluated</strong>,
as do blocks are simply a fancy way of rewriting
a <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span>-separated chain of expressions.
In fact, any container type
which implements <span class="docutils literal"><span class="pre">&gt;&gt;=</span></span> and <span class="docutils literal"><span class="pre">return</span></span> is a monad.
We have not yet seen
how Haskell can overload functions to take arbitrary types.
This is done through Haskell’s typeclasses.</p>
<p>We will cover typeclasses in a next post,
along with more monad examples.</p>
</div>
<div class="section" id="something-to-blow-your-mind">
<h2>Something to Blow Your Mind</h2>
<ol class="arabic">
<li><p class="first">Our attempt at proving Fermat’s theorem using Haskell
leads to a never ending evaluation,
quite logically so.</p>
<p>Explain why:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="p">[</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span>
                 <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>might not end either (depending on the details of the compiler)
although the list is non-empty, but:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">null</span> <span class="p">[</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">4</span><span class="o">..</span><span class="p">],</span>
                 <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">x</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">z</span> <span class="o">^</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>might be evaluated in finite time
(again depending on the details of the compiler).</p>
</li>
<li><p class="first">Fermat’s problem involved filtering,
but our poor man’s implementation did not implement filtering.
What extra operations do we need for our list monad
to gain filtering ability?</p>
<p>How could you abstract this to apply to general monads?</p>
<p>Hint. Analyze the following code:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">filt</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">filt</span> <span class="n">cond</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">cond</span> <span class="kr">then</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="kr">else</span> <span class="kt">[]</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="o">-</span><span class="n">x</span><span class="o">..</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">^</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;=</span>
<span class="nf">filt</span> <span class="p">(</span><span class="n">odd</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://stackoverflow.com/questions/11237076/haskell-precedence-lambda-and-operator">http://stackoverflow.com/questions/11237076/haskell-precedence-lambda-and-operator</a></td></tr>
</tbody>
</table>
</div>
</div>]]></description>
             <pubDate>Sat, 24 Aug 2013 00:00:00 +0100</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/21/everything_is_a_function.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/21/everything_is_a_function.html</guid>
            <title><![CDATA[Everything is a Function]]></title>
            <description><![CDATA[<div class="section" id="everything-is-a-function">
<h1>Everything is a Function</h1>
<div class="section" id="monads-and-the-magic-blob">
<h2>Monads and The Magic Blob</h2>
<p>Everyone who starts learning Haskell eventually hits monads.
In fact, it ought to be the first thing to start with in Haskell:
remember how any Haskell program essentially does one thing, namely
evaluating the <span class="docutils literal"><span class="pre">main</span></span> function?
Guess what <span class="docutils literal"><span class="pre">main</span></span> returns: yes, indeed, a monad.</p>
<p>Many (though certainly not all) tutorials I came across
start with treating monads—specifically, the IO monad—as
some kind of a magical blob.
In retrospect, now that I <em>think</em> to have an at least somewhat
sufficiently accurate understanding of
what monads do, and what role they play in functional languages,
it makes sense to me to try to understand monads first,
before diving into the IO monad magic.</p>
<p>So, my aim is to try to explain in the next few posts how monads work
in a pure functional language,
and how they allow you to refactor your code to be more beautiful—because
that is what Haskell is all about, beautiful code!
Apparently, monads are <em>also</em> useful for functions that have side effects,
i.e. functions whose result
does not depend only on the value of their arguments.
Once we have a good understanding of what monads are,
our plan is to look at the implementation of the IO monad,
to finally understand the magic.</p>
</div>
<div class="section" id="functions">
<h2>Functions</h2>
<p>Before we look at monads,
it is useful to reflect on how Haskell works with functions,
and how it provides really convenient notation
for combining simple functions together to make up really complex functions.
That is the main purpose of the current post.</p>
<p>First, how do we denote functions?
In Haskell, functions have a name, and one argument.
Yes, all functions have a single argument—we will see in a bit how we
can fake functions with multiple arguments.
It is a good habit, although not necessary, to annotate your functions
with a so-called type signature:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">increment</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>In the above, <span class="docutils literal"><span class="pre">Int</span></span> is simply the name of the type for integers in Haskell.
The code declares the fact that the function, named <span class="docutils literal"><span class="pre">increment</span></span>,
takes an integer, and returns an integer.
Once we have this, we can define the function itself:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">increment</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The left hand side denotes the function name (<span class="docutils literal"><span class="pre">increment</span></span>)
and its argument (<span class="docutils literal"><span class="pre">x</span></span>).
Note that we do not need to use brackets for the function argument:
a space denotes function application.
This may seem a bit weird at first,
but one gets used it quite quickly:
it makes for neat code.</p>
<p>The right hand side denotes the expression used to evaluate the function,
namely <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span>, which does what you expect.
We already have something weird here: surely, addition is a function too.
How can we write <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> if every function takes just a single argument?
And why is the function, <span class="docutils literal"><span class="pre">+</span></span>, denoted in between of its arguments?
Well, there are two things going on:</p>
<ul>
<li><p class="first"><span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> is just an alternative notation for <span class="docutils literal"><span class="pre">((+)</span> <span class="pre">x)</span> <span class="pre">1</span></span>.</p>
</li>
<li><p class="first">As the notation in the previous point already suggests,
<span class="docutils literal"><span class="pre">(+)</span></span> is <em>a function which returns another function</em>:
<a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>The brackets around the plus symbol
distinguish the <em>infix</em> notation
<span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> from the <em>prefix</em> notation <span class="docutils literal"><span class="pre">((+)</span> <span class="pre">x)</span> <span class="pre">1</span></span>.</p>
</li>
</ul>
<p>So, <span class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></span> first evaluates <span class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></span>,
which is a function with type signature <span class="docutils literal"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></span>.
Consequently, we apply this function to the argument <span class="docutils literal"><span class="pre">1</span></span>,
to get an integer back.
To make the confusion complete,
observe that we can also denote <span class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></span> as <span class="docutils literal"><span class="pre">(x+)</span></span>.
Cool.</p>
<p>Here is the full code,
which you can save as <span class="docutils literal"><span class="pre">test.hs</span></span> and run with <span class="docutils literal"><span class="pre">runghc</span> <span class="pre">test.hs</span></span>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">increment</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">increment</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">increment</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>The type signature of <span class="docutils literal"><span class="pre">main</span></span> is a bit strange: main takes no arguments,
and returns something that has type <span class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></span>.
In fact, <span class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></span> is a monad.
For now, suffice it to say that
to get an IO monad out of some result, we can use the <span class="docutils literal"><span class="pre">print</span></span> function.
Coincidently, <span class="docutils literal"><span class="pre">print</span></span> will also print its argument to the screen,
which is rather convenient.</p>
<p>A few conventions help us with reducing bracket bloat.</p>
<ol class="arabic">
<li><p class="first">The mapping operator <span class="docutils literal"><span class="pre">-&gt;</span></span> in type signatures is right-associative,
so we can write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Space (for function application) is left-associative,
so we can write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span> <span class="mi">1</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first">Space (for function application)
has higher precedence than any other operator.</p>
</li>
</ol>
<p>Note that, earlier, we put brackets around <span class="docutils literal"><span class="pre">increment</span> <span class="pre">5</span></span>
to apply its outcome to the <span class="docutils literal"><span class="pre">print</span></span> function. Had we omitted those brackets,
as in:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="n">increment</span> <span class="mi">5</span>
</pre></div>
</div>
<p>then the compiler would have interpreted this as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="p">(</span><span class="n">print</span> <span class="n">increment</span><span class="p">)</span> <span class="mi">5</span>
</pre></div>
</div>
<p>due to the left-associativity of the space operator
(as function application),
which is obviously wrong.
In fact, Haskell will give you a compile error on such code,
because the expression fails the type checks.
Indeed, type checks do prevent a rather frequent cause
of sometimes hard to track bugs;
that is why those type signatures are especially important.</p>
<p>Anyway, with this knowledge, we can now for instance define:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">affine</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">affine</span> <span class="n">a</span> <span class="n">b</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span>
<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>There are two more infix operators which help us with readability.</p>
<p>First, the <span class="docutils literal"><span class="pre">$</span></span> operator denotes function application,
so it is identical to the space operator,
with the only difference that <span class="docutils literal"><span class="pre">$</span></span> has very low precedence
and is right-associative,
whereas space has very high precedence
and is left-associative.
Thus, we can simplify the last line and write:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">$</span> <span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</pre></div>
</div>
<p>Finally, the <span class="docutils literal"><span class="pre">.</span></span> operator denotes function composition.
Here is its definition:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">$</span> <span class="n">g</span> <span class="n">x</span>
</pre></div>
</div>
<p id="type-variables">In the above, <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span>, are generic placeholders
for any type our heart desires; we say that <span class="docutils literal"><span class="pre">.</span></span> is polymorphic,
and <span class="docutils literal"><span class="pre">a</span></span>, <span class="docutils literal"><span class="pre">b</span></span>, and <span class="docutils literal"><span class="pre">c</span></span> are called <em>type variables</em>.
They are similar to template arguments in C++.</p>
<p><span class="docutils literal"><span class="pre">.</span></span> has higher precedence than <span class="docutils literal"><span class="pre">$</span></span>, but lower precedence
than space.
Function composition is associative, so if we chain functions together
through composition, there is no need to write brackets to denote
the order of composition.</p>
</div>
<div class="section" id="something-to-blow-your-mind">
<h2>Something to Blow Your Mind</h2>
<p>Explain why:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">.</span> <span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="o">$</span> <span class="mi">3</span>
</pre></div>
</div>
<p>is the same as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="o">$</span> <span class="n">affine</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="section" id="lessons-learned">
<h2>Lessons Learned</h2>
<ul class="simple">
<li>A function that takes multiple arguments can be modelled as a
function which returns another function.</li>
<li>Space is an operator: it applies functions to arguments, and it
is left-associative, which saves us brackets when working with functions
that take multiple arguments.</li>
<li>A dollar <span class="docutils literal"><span class="pre">$</span></span> is like space, but with very low precedence, and it is
right-associative.</li>
<li>A dot <span class="docutils literal"><span class="pre">.</span></span> denotes function composition. It is associative,
and has medium precedence (higher than <span class="docutils literal"><span class="pre">$</span></span>, and actually also
higher than all the usual binary operators, but lower than space).</li>
<li>Mapping operators <span class="docutils literal"><span class="pre">-&gt;</span></span> in type signatures are right-associative, which
saves us brackets, again, when working with functions that take
multiple arguments.</li>
<li>The standard binary infix operators (<span class="docutils literal"><span class="pre">+</span></span>, <span class="docutils literal"><span class="pre">*</span></span>, <span class="docutils literal"><span class="pre">-</span></span>, <span class="docutils literal"><span class="pre">/</span></span>,
and so on) can be used
in prefix notation—i.e. as normal functions—by
surrounding them with brackets.
It is now not clear why this is useful—just take it on faith that
there are plenty of situations where
it is useful to pass these operators as arguments of other functions,
which is made possible through the prefix notation.</li>
<li>A function can be polymorphic through type variables in its type signature.</li>
<li>For now, <span class="docutils literal"><span class="pre">main</span></span> returns magic blob.
For the time being, we will use <span class="docutils literal"><span class="pre">print</span></span> to blobify our final result,
and be happy in our ignorance.</li>
</ul>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Actually, the type signature is <span class="docutils literal"><span class="pre">(+)</span> <span class="pre">::</span> <span class="pre">Num</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></span>
but let us not get ahead of ourselves.</td></tr>
</tbody>
</table>
</div>
</div>]]></description>
             <pubDate>Wed, 21 Aug 2013 00:00:00 +0100</pubDate>
        </item>
    
        <item>
            <link>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/19/what_is_haskell_.html</link>
            <guid>http://mcmtroffaes.github.io/blowyourmindwithhaskell/2013/08/19/what_is_haskell_.html</guid>
            <title><![CDATA[What is Haskell?]]></title>
            <description><![CDATA[<div class="section" id="what-is-haskell">
<h1>What is Haskell?</h1>
<p>Did you see <a class="reference external" href="http://www.youtube.com/watch?v=Uooh0Y9fC_M">John Carmack’s keynote at QuakeCon 2013</a>?
I was deeply intrigued by his comments about Haskell,
and by his statement that every programmer should learn Haskell
to write more so-called pure functional code,
thereby reducing bugs and increasing productivity.</p>
<p>Apparently, <strong>Haskell is beautiful</strong>.
Everybody says.
More than enough reason for me!
So, last week, I set myself the task to learn Haskell.
I worked through Chapters 1–7 of
<a class="reference external" href="http://book.realworldhaskell.org/read">Real World Haskell</a>
in reasonable depth,
and started scratching the surface of Chapters 8–15.
This post is a brief summary of my experience so far.</p>
<p>Then, first, what is Haskell?
Haskell is a programming language with a particular set of restrictions:</p>
<ol class="arabic simple">
<li>All values are <em>immutable</em> (i.e. <span class="docutils literal"><span class="pre">const</span></span> if you come from C++).
This may seem weird at first, but in fact, it is not as bad as it sounds.</li>
<li>All values are either
<em>data</em>
(integers, characters, but also lists, records, unions, and so on),
or <em>functions</em>.
These values can be composed together to make <em>expressions</em>
(as in any other programming language).
Classes as you may know them from the Object Oriented world
do not exist in Haskell.</li>
<li>The compiler assumes that functions are
<a class="reference external" href="http://en.wikipedia.org/wiki/Pure_function">pure</a>:
if you call the same pure function with the same arguments,
then you will always get the same result back.
In other words, pure functions are functions in a mathematical sense.
For example, <span class="docutils literal"><span class="pre">getch</span></span> is an impure function in C:
its result is not deterministic.</li>
<li>All values are <em>statically typed</em>, that is,
their type is fixed at compile time.</li>
<li>At runtime, a Haskell program simply evaluates the expression
called <span class="docutils literal"><span class="pre">main</span></span>.</li>
<li>Evaluation is <em>lazy</em>, that is, expressions are only evaluated when
their result is required for the evaluation of <span class="docutils literal"><span class="pre">main</span></span>.</li>
<li>There is no specified order in which subexpressions
are evaluated, i.e. the compiler may resolve the evaluation in any
way deemed appropriate (potentially, even in parallel). <a class="footnote-reference" href="#id2" id="id1">[1]</a></li>
</ol>
<p>For someone coming from, say, Python or C++,
some of these restrictions are highly peculiar, specifically,
immutability, laziness,
and execution through evaluation of a single expression.
In more traditional languages,
you essentially tell the computer what to do, step by step.
In Haskell, you specify an expression you want to be evaluated,
and the compiler figures out the steps to arrive at the result.</p>
<p>All in all, the Haskell approach
has a number of important practical implications:</p>
<ol class="arabic simple">
<li>Due to delegating more work to the compiler,
Haskell programs
are typically much shorter than,
say, their equivalent Python/C++/&lt;insert-your-language-here&gt; implementations.</li>
<li>Haskell encourages you to write beautiful code:
due to its emphasis on purity,
there is a natural focus
on hierarchically decomposing the
problem into simple self-contained expressions,
often leading to highly modularized
self-explanatory code.
Surely, that is a good thing!</li>
<li>We cannot completely kick the habit of impurity,
because I/O is an essential aspect of nearly every program!
Nevertheless, at first sight,
non-trivial I/O
with a compiler that expects only pure functions
and immutable data, appears to be difficult, if not impossible.</li>
</ol>
<p>The latter is a bummer.
It is wildly surprising that Haskell can work
with impure functions in a sane way.
To do so, we have to rely on a generic but very useful
system called a <em>monad</em>.
I hope to write a bit more about monads in the next few posts.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is not entirely true.
Some functions guarantee that certain of their arguments
are evaluated first,
even if the evaluation of those arguments is not needed.
The only purpose this serves is
to help the compiler to produce more efficient machine code.
In principle,
a really clever compiler would not need such hints.
Also see:
<a class="reference external" href="http://www.haskell.org/haskellwiki/Performance/Strictness">http://www.haskell.org/haskellwiki/Performance/Strictness</a></td></tr>
</tbody>
</table>
</div>]]></description>
             <pubDate>Mon, 19 Aug 2013 00:00:00 +0100</pubDate>
        </item>
    
    </channel>
</rss>